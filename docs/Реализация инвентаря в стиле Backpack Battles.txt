Техническая спецификация реализации инвентарной системы и механик Backpack Battles в движке Cursed Warden
1. Архитектурный обзор и фундаментальные принципы интеграции
1.1. Введение и постановка задачи
Настоящий отчет представляет собой исчерпывающее техническое руководство по внедрению системы управления инвентарем, полностью идентичной механикам игры Backpack Battles, в проект Cursed Warden. Согласно имеющимся данным, репозиторий проекта Cursed Warden базируется преимущественно на языке C++ (86.1%) с элементами C (12.7%).1 Это накладывает специфические требования к архитектуре, отличающие её от реализаций на управляемых языках (таких как C# в Unity или GDScript в Godot), на которых обычно создаются подобные авто-батлеры.2 Задача заключается в портировании высокоуровневых механик, таких как пространственный тетрис инвентаря, динамические графы синергий, крафтинг через смежность и симуляция экономики магазина, в строго типизированную среду C++ с ручным управлением памятью.
Целью разработки является создание модульной, data-driven системы, где каждый предмет представляет собой не просто запись в базе данных, а активную пространственную сущность, взаимодействующую с соседями в реальном времени. Мы должны обеспечить точное воспроизведение "game feel" оригинала: вязкость перетаскивания, мгновенный отклик привязки к сетке (snapping), визуализацию связей (золотые/синие линии) и логику слияния предметов (fusion).4
1.2. Особенности движка и выбор паттернов проектирования
Учитывая, что Backpack Battles разработана на Godot 2, который использует узловую систему (Node-based) и сигналы, для реализации аналогичного функционала на C++ в Cursed Warden необходимо применить архитектурный паттерн Entity Component System (ECS) или, как минимум, Composite Pattern с мощной системой событий (Event Bus). Это позволит достичь необходимой гибкости при создании сложной вложенности контейнеров (сумка внутри инвентаря, предмет внутри сумки) без создания глубоких иерархий наследования, которые могут усложнить поддержку кода.
Ключевые архитектурные модули, которые будут подробно рассмотрены:
1. Grid System (Сетка): Математическая модель пространства, поддерживающая непрямоугольные формы и вложенные контейнеры.
2. Item Factory (Фабрика предметов): Система генерации экземпляров предметов на основе статических определений (Flyweight pattern).
3. Synergy Graph (Граф синергий): Алгоритмический модуль для расчета взаимных баффов в реальном времени.
4. Interaction Controller (Контроллер взаимодействия): Машина состояний для обработки ввода, Drag&Drop и ротации.
5. Battle Simulator (Симулятор битвы): Детерминированный движок для асинхронного расчета исхода боя.
1.3. Терминология и стандартизация
Для обеспечения однозначности интерпретации инструкций ИИ-генераторами кода вводим следующую терминологию:
* UnitTile (Тайл): Минимальная неделимая единица пространства (1x1).
* GridContainer (Контейнер): Логическая область, содержащая набор тайлов (например, Рюкзак, Пояс для зелий).
* OccupancyMap (Карта занятости): Двумерный массив или битовая маска, определяющая состояние каждого тайла (свободен, занят, заблокирован, невалиден).
* ItemFootprint (Отпечаток предмета): Матрица формы предмета с учетом его текущей ротации.
* AnchorPoint (Точка привязки): Координата (0,0) в локальной системе предмета, соответствующая верхнему левому углу его отпечатка.
* Socket (Сокет/Слот): Специализированная зона воздействия предмета (звезды, ромбы), проецирующая эффекты на соседние тайлы.
________________
2. Математическая модель пространственной сетки (Grid System)
Основой механики Backpack Battles является не просто список предметов, а их геометрия. В отличие от стандартных RPG, где инвентарь — это массив ячеек, здесь инвентарь — это составная геометрическая фигура, которая может расширяться и менять форму.
2.1. Иерархическая структура контейнеров
В Cursed Warden необходимо реализовать систему, где "Главная сетка" (Master Grid) является виртуальным пространством, в которое помещаются "Сумки" (Bags). Сами предметы помещаются внутрь сумок, но для игрока это выглядит как единое поле.
2.1.1. Виртуальная координатная плоскость
Мы определяем глобальную координатную систему инвентаря GlobalGrid. Пусть это будет пространство размером W x H (например, 20x20 тайлов), которое изначально пусто и неактивно.
* Bag Entity (Сущность сумки): Сумка (например, Leather Bag или Fanny Pack 6) — это предмет, который, будучи помещенным в GlobalGrid, активирует подмножество тайлов, делая их валидными для размещения других предметов.
* Координатная трансформация:
Для любого предмета Item, находящегося в координатах (localX, localY) внутри сумки Bag, которая находится в координатах (bagX, bagY) глобальной сетки, глобальные координаты предмета вычисляются как:

$$GlobalX = bagX + localX$$
$$GlobalY = bagY + localY$$

Однако, в Backpack Battles предметы часто могут занимать тайлы, принадлежащие разным сумкам, если они физически соприкасаются. Поэтому более эффективным подходом для C++ будет использование единой карты занятости.
2.1.2. Реализация OccupancyMap на C++
Вместо множества мелких массивов рекомендуется использовать единый двумерный массив указателей для всего поля инвентаря. Это обеспечит O(1) доступ к данным о соседстве, что критично для расчета синергий.
Структура данных TileCell:


C++




enum TileState {
   INVALID,    // Тайл не существует (пустота за пределами сумок)
   VALID,      // Тайл активирован сумкой, но пуст
   OCCUPIED,   // Тайл занят предметом
   LOCKED      // Тайл заблокирован (особые механики)
};

struct TileData {
   TileState state;
   uint32_t bagID;       // ID сумки, которой принадлежит этот тайл
   uint32_t itemID;      // ID предмета, занимающего тайл (если есть)
   Effect* activeBuffs;  // Указатель на кэшированные эффекты (например, ускорение от Fanny Pack)
};

Такая структура позволяет мгновенно проверить: "Принадлежит ли этот тайл сумке, дающей бонус к скорости?" (проверка bagID и свойств сумки).
2.2. Топология предметов и матричные трансформации
Предметы в Backpack Battles имеют сложные формы (L-образные, T-образные и т.д.).7 Для их описания используется матрица булевых значений.
2.2.1. Определение формы
Каждый предмет должен хранить свою базовую форму (BaseShape) в виде std::vector<std::vector<bool>> или битовой маски std::bitset.
Например, T-образный предмет (3 шириной, 2 высотой):


$$\begin{bmatrix} 1 & 1 & 1 \\ 0 & 1 & 0 \end{bmatrix}$$
В памяти C++ это должно быть линеаризовано для оптимизации кэша, но логически обрабатываться как 2D массив.
2.2.2. Алгоритм ротации
В Backpack Battles предметы можно вращать на 90 градусов. Вращение в C++ требует пересчета матрицы формы и коррекции точки привязки (Anchor Point).
При вращении по часовой стрелке координаты (x, y) в исходной матрице размером w x h переходят в координаты (h - 1 - y, x) в новой матрице размером h x w.
Критический нюанс реализации:
При вращении предмета его "визуальный центр" должен оставаться под курсором мыши. Если просто вращать матрицу относительно верхнего левого угла (0,0), предмет будет визуально "прыгать".
   * Решение: Необходимо вычислять смещение пивот-точки (Pivot Offset). Если курсор держит предмет за тайл (1,1), то после поворота этот тайл станет (1,0). Система должна пересчитать глобальные координаты AnchorPoint так, чтобы тайл под курсором остался на месте.
2.3. Валидация размещения (Collision Detection)
Функция CanPlaceItem(Item* item, int targetX, int targetY) является фундаментальной. Она должна выполняться в каждом кадре при перетаскивании (Drag state).
Алгоритм проверки:
   1. Получить текущую (возможно, вращенную) матрицу формы предмета.
   2. Итерировать по всем координатам (dx, dy), где матрица равна 1.
   3. Вычислить глобальные координаты: gx = targetX + dx, gy = targetY + dy.
   4. Проверить границы массива: если gx или gy вне диапазона GlobalGrid, вернуть false.
   5. Проверить TileData[gx][gy]:
   * Если state == INVALID (нет сумки) -> вернуть false.
   * Если state == OCCUPIED и itemID!= item->id (занято другим предметом) -> вернуть false.
   * Если state == LOCKED -> вернуть false.
   6. Если цикл завершен без ошибок -> вернуть true.
________________
3. Архитектура предметов и Data-Oriented Design
Для обеспечения высокой производительности и гибкости (как в Godot, но на C++) необходимо разделить данные и логику.
3.1. Разделение определений и экземпляров
В Cursed Warden следует использовать паттерн Flyweight (Приспособленец).
3.1.1. ItemDefinition (Статические данные)
Загружается один раз при старте игры из JSON/XML файлов. Хранит неизменяемые параметры.
   * ID: Уникальный хеш имени (например, hash("HERO_SWORD")).
   * Name, Description: Локализованные строки.
   * BaseStats: Урон, Кулдаун, Стоимость, Точность.
   * ShapeMatrix: Исходная форма.
   * Tags: Битовая маска или список тегов (WEAPON, MAGIC, FOOD, VAMPIRIC).6
   * SocketLayout: Карта расположения "звезд" и "ромбов" относительно AnchorPoint.
3.1.2. ItemInstance (Динамические данные)
Создается каждый раз, когда предмет появляется в игре (в магазине или инвентаре).
   * DefinitionPtr: Указатель на ItemDefinition.
   * GridPosition: Текущие координаты (x, y).
   * RotationState: Текущий угол (0-3).
   * RuntimeStats: Текущие значения статов с учетом модификаторов.
   * Modifiers: Список активных баффов (например, "+2 урона от соседнего камня").
3.2. Компонентная система свойств
Поскольку предметы имеют множество разнородных эффектов (вампиризм, шипы, регенерация маны) 8, жесткое наследование классов (class Sword : public Item) приведет к комбинаторному взрыву. Вместо этого следует использовать компонентную модель.
Структура ItemBehavior:
   * OnBattleStart()
   * OnTick(float deltaTime)
   * OnHit(Target* target)
   * OnInventoryUpdate(Grid* grid)
Каждый предмет может содержать список таких поведений. Например, Vampiric Potion будет иметь компоненты: HealthPotionBehavior (лечение) и VampiricBehavior (конвертация здоровья).
________________
4. Система взаимодействия (Input Controller) и UX
Ощущение от игры ("Game Feel") в Backpack Battles строится на тактильности взаимодействия. Реализация на C++ должна обеспечивать плавность, сравнимую с встроенными средствами движков.
4.1. Машина состояний ввода (Input FSM)
Контроллер ввода должен работать как конечный автомат со следующими состояниями:
4.1.1. State: IDLE (Ожидание)
   * Постоянный Raycasting от позиции курсора мыши в пространство сетки.
   * Если курсор над предметом:
   * Подсветить предмет (Highlight).
   * Отобразить всплывающую подсказку (Tooltip) с задержкой 0.2с.
   * Визуализация синергий: Нарисовать линии связей (синие/золотые) к соседним предметам, чтобы показать текущие активные эффекты без перетаскивания.4
4.1.2. State: DRAG_START (Начало перетаскивания)
   * Срабатывает при нажатии ЛКМ.
   * Логика отрыва:
   1. Запомнить исходные координаты предмета (OriginalPos).
   2. Удалить предмет из OccupancyMap (логически "поднять" его), освободив тайлы.
   3. Переключить рендеринг предмета в слой Overlay (поверх всего).
   4. Создать полупрозрачную копию ("призрак") на исходном месте, если это требуется дизайном, или оставить пустым.
4.1.3. State: DRAGGING (Перетаскивание)
   * Выполняется каждый кадр.
   * Snapping (Привязка): Конвертировать экранные координаты мыши в индексы сетки. Предмет должен "липнуть" к сетке, перемещаясь дискретно по тайлам, но сам спрайт может двигаться плавно с интерполяцией (Lerp) для визуальной мягкости.
   * Предиктивная валидация:
   * Вызвать CanPlaceItem для текущих координат.
   * Если true -> Подкрасить спрайт зеленым.
   * Если false -> Подкрасить спрайт красным.
   * Обработка ротации: При нажатии ПКМ вращать матрицу предмета и пересчитывать валидацию.
   * Обработка сумок: Если перетаскивается Сумка (Bag), необходимо рекурсивно проверить содержимое. В Backpack Battles перетаскивание сумки перемещает и все предметы внутри неё.4
   * Алгоритм: При поднятии сумки, найти все предметы, чьи координаты попадают в зону этой сумки. Временно "привязать" их к сумке (parenting). При проверке валидности размещения сумки проверять валидность размещения всех дочерних предметов в новых глобальных координатах.
4.1.4. State: DROP (Сброс)
   * Срабатывает при отпускании ЛКМ.
   * Если позиция валидна:
   1. Записать новые координаты в ItemInstance.
   2. Обновить OccupancyMap (пометить тайлы как занятые).
   3. Воспроизвести звук "Thud" или "Click".
   4. Отправить событие Event_InventoryChanged.
   * Если позиция невалидна:
   1. Вернуть предмет на OriginalPos с анимацией возврата (tweening).
   2. Восстановить занятость тайлов в OccupancyMap.
4.2. Особые механики взаимодействия
   * Swap (Обмен местами): Если игрок бросает предмет А на предмет Б, и они имеют одинаковый размер/форму (или предмет А помещается на место Б, а Б — на место А), система должна автоматически поменять их местами. Это требует двойной проверки валидации.
   * Multi-Select: Реализация выделения рамкой (drag selection) для перемещения группы предметов.4 Это требует временного создания виртуального контейнера для группы.
   * Storage (Хранилище): В игре есть зона "Сундук" (Storage), где предметы хранятся, но не активны.6 Технически это отдельный Grid с флагом IsActive = false. Предметы в нем не участвуют в расчетах синергий.
________________
5. Движок синергий (Synergy Engine) и Графовая логика
Это самая сложная часть логики Backpack Battles. Предметы усиливают друг друга в зависимости от расположения, поворота и тегов.
5.1. Типология связей
В игре существуют разные типы воздействия 6:
   1. Adjacency (Смежность): Простое соседство (например, Whetstone усиливает оружие вокруг).
   2. Socket/Star (Звезды): Направленное воздействие. Предмет имеет "звезду" в определенной ячейке сетки (относительно своего центра). Если в эту ячейку попадает другой предмет, эффект срабатывает.
   3. Category Matching (Теги): Эффект срабатывает только если сосед имеет определенный тег (например, "Food" или "Dark").
5.2. Алгоритм пересчета (RecalculateSynergies)
Этот алгоритм должен запускаться при каждом событии Event_InventoryChanged (после Drop или Rotate). Учитывая синхронную природу инвентаря, пересчет всего графа допустим (N предметов < 100), но должен быть оптимизирован.
Шаг 1: Очистка (Flush)
Пройти по всем предметам и сбросить их ModifierStats (временные бонусы) в 0. Снять флаги IsFused.
Шаг 2: Построение графа влияний
Итерируем по каждому предмету (Source):
   1. Получить список его активных сокетов (звезд).
   2. Для каждого сокета вычислить глобальную координату:

$$SocketGlobal = SourcePos + RotateVector(SocketLocalOffset, SourceRotation)$$
   3. Обратиться к OccupancyMap по координатам SocketGlobal.
   4. Если тайл занят предметом (Target) и Target!= Source:
      * Проверить совместимость: Target->HasTag(Source->RequiredTag).
      * Если совместим -> Добавить модификатор в Target.
      * Пример: Если Source — Whetstone, а Target — Sword, добавить +1 Damage к Target.
Шаг 3: Разрешение циклических зависимостей
Некоторые предметы могут усиливать друг друга (взаимные баффы). В Backpack Battles большинство баффов аддитивные, но есть и мультипликативные (например, ускорение).10
      * Порядок выполнения: Сначала применять аддитивные модификаторы (Damage +1), затем мультипликативные (Speed +10%). Это предотвращает "взрыв" значений.
      * Сумки: Эффекты сумок (например, +10% крит шанс для предметов внутри) применяются отдельным проходом. Проверяем каждый предмет: "В какой сумке находится мой центр?". Если в Fanny Pack, применить бафф.
5.3. Механика слияния (Fusion/Crafting)
Слияние — это уникальная механика, где предметы превращаются в новые.5
5.3.1. Структура рецепта


C++




struct Recipe {
   std::vector<uint32_t> ingredients; // Хеши компонентов
   uint32_t resultItemID;             // Хеш результата
   bool requiresAdjacency;            // Обычно true
};

5.3.2. Логика обнаружения
В процессе пересчета синергий (Шаг 2), если два предмета являются смежными, проверяем их пару по базе рецептов.
      * Если пара найдена в базе рецептов:
      * Отрисовать Золотую Линию между ними.4
      * Установить флаг FuseReady = true для обоих предметов.
      * Если найден только один компонент из сложного рецепта (например, нужно 2 меча, а есть 1), отрисовать тонкую линию (подсказку).5
5.3.3. Исполнение слияния
Слияние происходит не мгновенно, а при триггере (начало раунда или вход в магазин).
      1. Удалить исходные предметы (Ingredients) из сетки.
      2. Создать новый предмет (Result).
      3. Попытаться разместить Result в точке привязки "главного" ингредиента (обычно того, который был поставлен первым или имеет высший ранг).
      4. Если Result не помещается (он больше исходных), попытаться разместить в ближайшем свободном месте или отправить в Storage.
________________
6. Экономическая система и Магазин
Магазин в Backpack Battles — это, по сути, еще один инвентарь с особыми правилами.4
6.1. Генерация ассортимента (Shop Logic)
Ассортимент зависит от номера раунда и редкости.
      * Loot Tables: Использовать взвешенные списки (Weighted Lists). Веса меняются динамически.
      * Раунд 1-2: Common (90%), Rare (10%).
      * Раунд 8+: Добавляются Legendary и Godly.
      * Алгоритм Reroll:
      1. Очистить сетку магазина (кроме зарезервированных предметов).
      2. Сгенерировать 5 новых предметов.
      3. Разместить их в сетке магазина (авто-упаковка).
      4. Распродажа (Sale): Каждый предмет имеет 10% шанс получить флаг OnSale (цена / 2).6
6.2. Транзакции
      * Покупка: Перетаскивание из зоны Магазина в зону Инвентаря.
      * Проверка: PlayerGold >= ItemCost.
      * Действие: Списать золото, сбросить флаг принадлежности магазину.
      * Продажа: Перетаскивание в зону "Chestnut" (сундук продажи).4
      * Цена продажи = ceil(ItemCost / 2).
      * Важно: Если предмет был куплен по скидке (50%), его цена продажи равна цене покупки. Это позволяет "арендовать" предметы бесплатно. Системе необходимо хранить поле OriginalPurchasePrice в ItemInstance.
      * Резервирование (Lock): По клику ПКМ или специальной кнопке предмет в магазине "замораживается". При реролле он не удаляется. Технически это флаг IsLocked в ItemInstance.
________________
7. Симуляция боя (Auto-Battler Simulation)
Хотя запрос касался инвентаря, инвентарь бесполезен без контекста боя. Битва в Backpack Battles асинхронна и детерминирована.
7.1. Подготовка данных (Snapshot)
Перед боем создается "Снимок" (Deep Copy) инвентаря игрока. Это критично, так как во время боя предметы могут менять свои параметры (наращивать урон, тратить стамину), но эти изменения не должны сохраняться после боя.
7.2. Временная шкала (Timeline Simulation)
Симуляция не должна зависеть от FPS рендеринга. Используется фиксированный шаг времени (Fixed Time Step), например, 0.016с (60 тиков/сек).
Алгоритм тика:
      1. Stamina Check: Проверить регенерацию стамины.
      2. Cooldowns: Уменьшить таймеры кулдауна всех предметов. Учитывать модификаторы скорости (Haste, Cold).
      3. Activation: Если Cooldown <= 0 и CurrentStamina >= ItemStaminaCost:
      * Выполнить действие (Урон, Хил, Наложение баффа).
      * Списать стамину.
      * Сбросить кулдаун (BaseCooldown / SpeedMultiplier).
      4. Event Bus: Все действия (удар, блок, уворот) отправляются в шину событий. Это позволяет предметам реагировать друг на друга (например, Shield блокирует урон при событии Event_TakeDamage).
7.3. Логирование (Combat Log)
Все события записываются в текстовый лог. Структура лога должна быть сериализуемой, чтобы игрок мог развернуть его и посмотреть детали ("Round 1, 0:05: Hero Sword dealt 5 dmg").11
________________
8. Реализация на C++: Специфические рекомендации
Учитывая использование C++ в Cursed Warden, следует придерживаться следующих практик для достижения высокой производительности.
8.1. Управление памятью
      * Использовать std::shared_ptr<ItemInstance> для владения предметами. Сумка владеет предметами внутри себя? Нет, лучше, чтобы InventoryManager владел всеми предметами в плоском списке std::vector<shared_ptr<ItemInstance>>, а сетка хранила лишь weak_ptr или сырые указатели для быстрого доступа. Это упростит перенос предметов между сумками (не нужно менять владельца памяти, только ссылку в сетке).
      * Для матриц форм использовать std::bitset (для предметов до 4x4), что позволит выполнять проверки коллизий через побитовые операции (&, |), что на порядки быстрее циклов.
8.2. Сериализация (Сохранение)
Для сохранения состояния инвентаря (JSON/Binary):
      * Сохранять не полную матрицу, а только: ID определения, координаты (x,y), ротацию, текущую прочность/стаки.
      * При загрузке: Создать новый ItemInstance по ID, применить сохраненные параметры, поместить в сетку.
8.3. Интеграция с UI
Поскольку C++ логика отделена от рендеринга, необходимо создать слой-адаптер.
      * Observer Pattern: UI подписывается на события Inventory.
      * Когда логика меняет состояние (предмет добавлен), UI получает сигнал и перерисовывает соответствующую часть сетки. Это предотвращает рассинхронизацию между данными ("что есть на самом деле") и картинкой.
________________
9. План-график внедрения (Roadmap)
Для ИИ-агента или разработчика, реализующего систему, рекомендуется следующий порядок действий:
      1. Этап 1: Базовая сетка. Реализовать GlobalGrid, TileData и рендеринг отладочной сетки.
      2. Этап 2: Drag&Drop. Реализовать перетаскивание прямоугольников с привязкой к сетке (без коллизий).
      3. Этап 3: Формы и Коллизии. Внедрить матрицы форм, ротацию и проверку CanPlaceItem.
      4. Этап 4: Сумки. Реализовать логику сумок как активаторов тайлов.
      5. Этап 5: Синергии (Backend). Реализовать поиск соседей и расчет статов.
      6. Этап 6: Визуализация. Добавить отрисовку линий связей, призраков предметов, подсветку валидности.
      7. Этап 7: Магазин и Крафт. Реализовать логику покупки/продажи и слияния предметов.
________________
10. Заключение
Реализация инвентарной системы уровня Backpack Battles в среде C++ проекта Cursed Warden — это задача по созданию сложного геометрического движка управления ресурсами. Ключ к успеху лежит в строгом разделении данных (сетка, предметы) и представления (спрайты, UI), а также в использовании эффективных алгоритмов графового обхода для системы синергий. Представленная архитектура обеспечивает масштабируемость (легкое добавление новых предметов и механик) и высокую производительность, необходимую для плавного пользовательского опыта.
Источники
      1. salmonslay/Sonder: Experience an innovative co-op adventure where two players have to work together. Engage in collaborative puzzle solving and dynamic combat with each player having unique abilities. - GitHub, дата последнего обращения: января 4, 2026, https://github.com/salmonslay/Sonder
      2. Shoutout to Backpack Battles that released today on steam (made with godot) - Reddit, дата последнего обращения: января 4, 2026, https://www.reddit.com/r/godot/comments/1b9rf6w/shoutout_to_backpack_battles_that_released_today/
      3. Simple Drag and Drop System in Unity, дата последнего обращения: января 4, 2026, https://unitycodemonkey.com/tutorial_text_contents_tinymce.php?v=BGr-7GZJNXg
      4. Communauté Steam :: Guide :: Game Basics, Clarifications, дата последнего обращения: января 4, 2026, https://steamcommunity.com/sharedfiles/filedetails/?l=french&id=3187896204
      5. Backpack Battles Recipe List - IGN, дата последнего обращения: января 4, 2026, https://www.ign.com/wikis/backpack-battles/Backpack_Battles_Recipe_List
      6. Items (demo) - The Backpack Battles Wiki, дата последнего обращения: января 4, 2026, https://backpackbattles.wiki.gg/wiki/Items_(demo)
      7. Backpack Battles - Wikipedia, дата последнего обращения: января 4, 2026, https://en.wikipedia.org/wiki/Backpack_Battles
      8. Game Mechanics - The Backpack Battles Wiki, дата последнего обращения: января 4, 2026, https://backpackbattles.wiki.gg/wiki/Game_Mechanics
      9. Items - The Backpack Battles Wiki, дата последнего обращения: января 4, 2026, https://backpackbattles.wiki.gg/wiki/Items
      10. Backpack Battles Mechanics & Tricks Thread : r/BackpackBattles - Reddit, дата последнего обращения: января 4, 2026, https://www.reddit.com/r/BackpackBattles/comments/1mtyvy3/backpack_battles_mechanics_tricks_thread/
      11. How do I make a good build? :: Backpack Battles Algemene discussies - Steam Community, дата последнего обращения: января 4, 2026, https://steamcommunity.com/app/2427700/discussions/0/4290313152627900682/?l=dutch