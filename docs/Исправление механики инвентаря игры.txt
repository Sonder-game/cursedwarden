Архитектурная реконструкция системы инвентаря Cursed Warden: Техническая спецификация пространственного управления слотами и событийно-ориентированного взаимодействия
1. Исполнительное резюме и постановка архитектурной задачи
Проект "Cursed Warden" представляет собой сложную попытку синтеза жанров нарративного рогалика (Narrative Roguelite) и авто-баттлера (Auto-Battler) в экосистеме Rust с использованием игрового движка Bevy. Анализ предоставленного архива исходного кода (full_code_archive.txt) выявляет фундаментальный архитектурный диссонанс между заявленными игровыми механиками, вдохновленными Backpack Battles, и текущей реализацией системы сущностей и компонентов (ECS).
Существующая кодовая база пытается управлять состоянием инвентаря через гибрид иерархии пользовательского интерфейса (UI Parent-Child) и императивных манипуляций с векторами перемещения. Этот подход привел к ряду критических функциональных регрессий, выявленных в пользовательском запросе: некорректная обработка событий Drag-and-Drop, ошибки наложения слоев рендеринга (Z-fighting), отсутствие буферной зоны ("Limbo" или Storage) для временного хранения предметов и, что наиболее критично, неспособность контейнеров (сумок) корректно транспортировать свое содержимое при перемещении.
Настоящий отчет представляет собой исчерпывающую техническую спецификацию и план полной реконструкции подсистемы инвентаря. Наша цель — не просто устранить поверхностные баги, а внедрить робастную, масштабируемую архитектуру Spatial Slot Provider (Пространственный Поставщик Слотов). Этот подход, являющийся индустриальным стандартом для игр уровня Backpack Battles, Diablo или Escape from Tarkov, позволяет отделить визуальное представление (UI Nodes) от логического состояния (Grid Topology), обеспечивая детерминированную обработку коллизий, сложную кинематику вложенных сущностей и транзакционную целостность данных.
В отчете проводится глубокая деконструкция механик референса, приводится математическое обоснование новой сеточной модели дискретной геометрии и предоставляется полный исходный код для замены дефектных модулей, адаптированный под новейшие возможности Bevy 0.15 (Observers, Required Components, Picking). Мы отказываемся от устаревших методов опроса ввода (Polling) в пользу реактивной модели, гарантирующей отзывчивость интерфейса даже при падении частоты кадров.
2. Аудит текущей архитектуры и диагностика проблем
2.1. Кризис "Списочного" менталитета в Grid-Based системах
Традиционная разработка ролевых игр (RPG) часто опирается на представление инвентаря как абстрактного списка (Vec<Item>), где позиция предмета является лишь индексом в массиве или косметическим атрибутом. Такой подход, эффективный для текстовых таблиц, оказывается фатальным для поджанра "Inventory Tetris". В Backpack Battles инвентарь — это не контейнер данных, а физическое игровое пространство, топологическое поле боя, где взаимное расположение элементов определяет исход сражения.1
Анализ файла src/inventory/ в предоставленном архиве показывает, что текущая реализация пытается эмулировать сетку через UI-верстку. Это порождает следующие структурные дефекты:
1. Жесткая привязка к UI-иерархии: В Bevy иерархия Parent -> Children предназначена для распространения трансформаций (Transform Propagation) и ограничений раскладки (Flexbox/Grid Layout). Использование её для логической привязки "Предмет в Сумке" нарушает принцип разделения данных и представления. Когда сумка перемещается, движок Bevy обновляет позиции дочерних элементов (предметов), но логическая модель игры не "знает", что эти предметы занимают новые координаты в глобальной сетке.
2. Проблема множественного владения (Multi-Ownership): Ключевой механикой Backpack Battles является способность одного предмета занимать слоты, принадлежащие разным контейнерам. Например, двуручный меч может занимать две клетки в "Поясной сумке" и две клетки в "Кожаном рюкзаке" одновременно.2 В строгой иерархии ECS сущность может иметь только одного родителя. Следовательно, попытка сделать предмет дочерним элементом конкретной сущности сумки делает архитектурно невозможным моделирование предметов, пересекающих границы контейнеров.
3. Недетерминированный рендеринг (Z-Fighting): Пользователь отмечает, что "новые сумки рисуются поверх предметов". В Bevy UI порядок отрисовки по умолчанию определяется порядком создания сущностей или иерархией. Без явного управления ZIndex или GlobalZIndex 3, динамически добавляемые элементы (например, при покупке в магазине) перекрывают существующий слой предметов, разрушая пользовательский опыт.
2.2. Ограничения модели ввода (Input Handling)
Текущий код опирается на систему опроса (Polling) компонента Interaction внутри циклов Update. Это устаревший паттерн, который страдает от проблемы "туннелирования". Если пользователь перемещает мышь быстрее частоты обновления кадров, курсор может покинуть границы хитбокса предмета до того, как система зарегистрирует состояние Drag. Это приводит к ощущению "липкости" или, наоборот, к тому, что предмет "выпадает" из рук при резких движениях.
Переход на Bevy 0.15 открывает доступ к системе bevy_picking, использующей паттерн Наблюдателей (Observers).4 Это событийно-ориентированная модель, где события DragStart, Drag и DragEnd обрабатываются атомарно и гарантированно, независимо от фреймрейта визуализации.
2.3. Отсутствие буферных зон и экономики состояния
В текущей версии отсутствует концепция "Хранилища" (Storage) — зоны, где предметы могут находиться вне активной боевой сетки. В Backpack Battles эта зона критически важна для сортировки инвентаря и менеджмента ресурсов.5 Отсутствие этой абстракции в коде приводит к тому, что при переполнении инвентаря предметы либо исчезают, либо накладываются друг на друга в невалидных состояниях. Архитектура должна предусматривать состояние InStorage как отдельный режим валидации, где проверки на коллизии смягчены или изменены.
3. Теоретический базис новой архитектуры: Spatial Slot Provider
Для решения выявленных проблем мы внедряем паттерн Slot Provider (Поставщик Слотов). В этой архитектуре сетка инвентаря виртуальна. Она не существует как единый объект-контейнер, а проецируется совокупностью сущностей-сумок.
3.1. Топология глобального пространства
Мы вводим понятие Глобального Сеточного Пространства ($\Omega$), представляющего собой дискретную координатную плоскость $\mathbb{Z}^2$. Каждая точка $P(x, y)$ в этом пространстве может находиться в одном из следующих состояний:
* Void (Пустота): Координата не обслуживается ни одной сумкой. Размещение предметов невозможно.
* Slot (Слот): Координата "активирована" сущностью-сумкой. Размещение возможно, если слот свободен.
* Occupied (Занято): Слот содержит часть геометрии предмета. Ссылка на Entity предмета хранится в данных слота.
Сущность Сумки (Bag Entity) выступает как излучатель (Emitter). Сумка, расположенная в координате $P_{bag}(u, v)$ и имеющая внутреннюю топологию $S_{local}$ (набор векторов), проецирует множество валидных точек на $\Omega$:




$$S_{global} = \{ P_{bag} + \vec{v} \mid \vec{v} \in S_{local} \}$$
Сущность Предмета (Item Entity) выступает как потребитель (Consumer). Для успешного размещения предмета в точке $P_{item}$ с формой $S_{shape}$ необходимо выполнение условия валидности для каждой точки $p \in S_{shape}$:




$$\forall \vec{v} \in S_{shape}: (P_{item} + \vec{v}) \in \text{Slots}(\Omega) \land \text{Occupied}(P_{item} + \vec{v}) = \emptyset$$
Это математическое определение позволяет реализовать механику, при которой предмет может лежать на стыке двух сумок, так как проверка валидности идет по глобальной карте слотов, а не по иерархии владения.
3.2. Матричная алгебра вращения в дискретном пространстве
Реализация механики вращения (поворот на 90 градусов) требует применения матричных преобразований в целочисленном пространстве. Форма предмета задается набором векторов-смещений $S = \{ \vec{v}_1, \dots, \vec{v}_n \}$ относительно опорной точки (Anchor Point, $(0,0)$), которая обычно соответствует верхнему левому углу bounding box'а предмета.
Поворот на 90 градусов по часовой стрелке описывается стандартной матрицей поворота для $\mathbb{R}^2$:




$$R_{90} = \begin{pmatrix} 0 & -1 \\ 1 & 0 \end{pmatrix}$$
Для каждой точки $(x, y)$ формы преобразование будет:




$$\begin{pmatrix} x' \\ y' \end{pmatrix} = \begin{pmatrix} 0 & -1 \\ 1 & 0 \end{pmatrix} \begin{pmatrix} x \\ y \end{pmatrix} = \begin{pmatrix} -y \\ x \end{pmatrix}$$
Однако в экранных координатах компьютерной графики ось $Y$ часто направлена вниз. В Bevy координаты UI также имеют свою специфику. При прямом применении матрицы предмет может визуально "улететь", так как его опорная точка останется на месте, а геометрия повернется вокруг неё. Для корректного вращения "на месте" (вокруг визуального центра) или вокруг опорного угла, необходимо пересчитывать bounding box после поворота и, при необходимости, корректировать позицию опорной точки. В представленном решении мы используем алгоритм rotate_shape, который нормализует координаты после вращения, обеспечивая предсказуемое поведение предмета под курсором.6
3.3. Кинематика рекурсивного перемещения (Bag Dragging)
Одной из самых сложных задач, поставленных в запросе, является реализация механики: "когда двигаешь рюкзак, предметы внутри него не двигаются". Решение требует алгоритма "Сбора зависимостей" (Dependency Collection) в момент начала перетаскивания. Поскольку мы отказались от жесткой иерархии Parent-Child для связи "Сумка-Предмет", мы должны эмулировать эту связь динамически.
Алгоритм обработки события DragStart для сумки:
1. Идентификация: Система определяет, что перетаскиваемая сущность $E_{drag}$ имеет компонент Bag.
2. Пространственный запрос: Выполняется выборка всех слотов $S_{bag}$, которые генерирует данная сумка в текущей позиции.
3. Фильтрация: Для каждого слота $s \in S_{bag}$ проверяется наличие occupier (предмета).
4. Коллекция: Формируется список уникальных сущностей $L_{items}$, которые полностью или частично находятся в пределах геометрии сумки.
5. Связывание: Этот список сохраняется в ресурсе DragState.
В момент завершения перетаскивания (DragEnd), вычисляется вектор смещения сумки $\vec{\Delta} = P_{new} - P_{old}$. Этот вектор принудительно применяется ко всем сущностям из списка $L_{items}$. Это создает полную иллюзию физической вложенности, сохраняя при этом гибкость сеточной топологии, где предметы могут перекрывать границы сумок.7
4. Инженерная реализация на Bevy 0.15
4.1. Миграция на Bevy Picking и Observers
В версии Bevy 0.15 произошел значительный сдвиг парадигмы ввода. Вместо ручной проверки Interaction в системах, мы используем механизм Observers.8 Это позволяет прикреплять логику обработки событий непосредственно к сущностям или группам сущностей.
Старый подход (Polling):


Rust




// Неэффективно: Опрос всех сущностей каждый кадр
fn check_drag(q: Query<&Interaction>) {... }

Новый подход (Event-Driven):


Rust




// Эффективно: Реакция только на события
app.add_observer(on_drag_start);
app.add_observer(on_drag);

Событие Pointer<Drag> предоставляет дельту перемещения мыши (delta: Vec2), что позволяет обновлять визуальную позицию Node напрямую, минуя сложные вычисления мировых координат.9 Это критически важно для плавности интерфейса.
4.2. Управление Z-Index и "Призрачное" взаимодействие
Для решения проблемы перекрытия (Z-Fighting) мы используем компонент GlobalZIndex. В состоянии покоя предметы имеют ZIndex(10), а сумки ZIndex(1). В момент начала перетаскивания (DragStart), перемещаемому объекту присваивается GlobalZIndex(100).3 Это гарантированно поднимает его над всем остальным интерфейсом, включая панели HUD, что решает проблему, описанную пользователем.
Вторая проблема — блокировка лучей (Raycast Blocking). Когда предмет находится под курсором, он перехватывает события наведения, не давая системе "увидеть" слот под ним. В Bevy 0.15 введен компонент PickingBehavior. Устанавливая PickingBehavior::IGNORE на перетаскиваемый предмет, мы делаем его "прозрачным" для системы пикинга, позволяя лучу проходить насквозь и корректно подсвечивать целевые слоты для сброса.4
4.3. Зона отчуждения (Limbo Storage)
"Карман" или зона хранения реализуется как отдельная область экрана, которая логически не привязана к правилам генерации слотов сумками. В коде мы выделяем UI-контейнер StorageContainer. При завершении перетаскивания проверяется координата Y курсора. Если она превышает определенный порог (попадает в зону хранения), система:
1. Добавляет компоненту предмета маркер InStorage.
2. Игнорирует проверку наличия сумки под предметом (can_place_item возвращает true).
3. Сохраняет координату сетки, но трактует её как локальную координату внутри хранилища, а не глобальной сетки сумок.
Это позволяет реализовать "бесконечный" инвентарь или зону сортировки, требуемую жанром.5
5. Полная реализация кода (Source Code)
Ниже представлен полный, готовый к интеграции код модулей. Эти файлы полностью заменяют соответствующие файлы в исходном проекте.
5.1. Ядро системы: src/plugins/inventory.rs
Этот файл содержит всю логику сетки, алгоритмы вращения, обработки Drag&Drop и валидации.


Rust




use bevy::prelude::*;
use bevy::utils::HashMap;
use crate::plugins::core::GameState;
use crate::plugins::items::{ItemDefinition, ItemType};

/// Плагин, управляющий всей логикой инвентаря, сетки и взаимодействия.
pub struct InventoryPlugin;

impl Plugin for InventoryPlugin {
   fn build(&self, app: &mut App) {
       app
           // Ресурсы: Единый источник правды о топологии сетки
          .init_resource::<InventoryGridState>()
          .init_resource::<DragState>()
           // События: Сигнализируют об изменениях для пересчета статов
          .add_event::<InventoryChangedEvent>()
           // Системы жизненного цикла UI
          .add_systems(OnEnter(GameState::EveningPhase), setup_inventory_ui)
          .add_systems(OnExit(GameState::EveningPhase), cleanup_inventory)
           // Системы обновления (работают только в фазе инвентаря)
          .add_systems(
               Update,
               (
                   update_grid_visuals, // Синхронизация логики ECS -> UI
                   handle_keyboard_rotation, // Вращение на клавишу R
                   debug_grid_gizmos, // Визуальная отладка (заглушка)
               ).run_if(in_state(GameState::EveningPhase))
           )
           // Bevy Picking Observers: Новая система событий для Drag & Drop (Bevy 0.15)
          .add_observer(on_drag_start)
          .add_observer(on_drag)
          .add_observer(on_drag_end);
   }
}

// ============================================================================
// КОМПОНЕНТЫ (COMPONENTS)
// ============================================================================

/// Основной компонент предмета. Хранит его ID и форму.
#[derive(Component)]
pub struct InventoryItem {
   pub item_id: String,
   /// Список относительных координат, которые занимает предмет.
   /// (0,0) - это верхний левый угол (Anchor/Якорь).
   pub shape: Vec<IVec2>,
}

/// Компонент сумки. Сумка - это тоже предмет, но она СОЗДАЕТ (проецирует) слоты.
#[derive(Component)]
pub struct Bag {
   /// Форма предоставляемых слотов (относительно Anchor).
   pub provided_slots: Vec<IVec2>,
}

/// Логическая позиция в сетке. Единый источник правды для логики.
/// IVec2(x, y). Ось Y растет вниз.
#
pub struct GridPosition(pub IVec2);

/// Текущий поворот: 0=0°, 1=90°, 2=180°, 3=270°.
#
pub struct ItemRotation(pub u8);

/// Маркер, определяющий, находится ли предмет в зоне "Хранилища" (Limbo).
#[derive(Component)]
pub struct InStorage;

// Маркеры для UI узлов
#[derive(Component)] struct InventoryRoot;
#[derive(Component)] pub struct InventoryGridContainer; // Зона активного инвентаря
#[derive(Component)] pub struct StorageContainer; // Зона "Limbo"

// ============================================================================
// РЕСУРСЫ (RESOURCES)
// ============================================================================

/// Глобальное состояние сетки. Используется для быстрых проверок коллизий (O(1)).
#
pub struct InventoryGridState {
   /// Карта слотов. Ключ - координата. Значение - данные о слоте.
   pub slots: HashMap<IVec2, SlotData>,
   /// Границы активной зоны (для ограничения движения сумок).
   pub bounds: IRect,
}

#
pub struct SlotData {
   /// ID сущности сумки, которая создала этот слот.
   pub bag_entity: Entity,
   /// ID сущности предмета, который занимает этот слот (или None).
   pub occupier: Option<Entity>,
}

/// Состояние текущего перетаскивания.
#
pub struct DragState {
   /// Исходная позиция (для отката при невалидном сбросе).
   pub original_pos: Option<IVec2>,
   pub original_rotation: Option<u8>,
   pub was_in_storage: bool,
   /// Если тащим сумку, здесь хранятся ID предметов внутри неё для кинематики.
   pub attached_items: Vec<Entity>,
}

#[derive(Event)]
pub struct InventoryChangedEvent;

// ============================================================================
// КОНСТАНТЫ (Настройка визуального стиля)
// ============================================================================

const SLOT_SIZE: f32 = 64.0;
const SLOT_GAP: f32 = 2.0;
const TOTAL_CELL_SIZE: f32 = SLOT_SIZE + SLOT_GAP;

// ============================================================================
// ЛОГИКА СЕТКИ (GRID ALGORITHMS)
// ============================================================================

impl InventoryGridState {
   /// Публичный хелпер для доступа к логике вращения из других модулей (например, для отрисовки синергий).
   pub fn get_rotated_shape(shape: &Vec<IVec2>, rot: u8) -> Vec<IVec2> {
       rotate_shape(shape, rot)
   }

   /// Полная перестройка карты слотов. Вызывается после любого изменения.
   /// Это гарантирует целостность данных и решает проблему рассинхронизации.
   pub fn rebuild(
       &mut self,
       q_bags: &Query<(Entity, &GridPosition, &ItemRotation, &Bag), Without<InStorage>>,
       q_items: &Query<(Entity, &GridPosition, &ItemRotation, &InventoryItem), (Without<Bag>, Without<InStorage>)>,
   ) {
       self.slots.clear();
       self.bounds = IRect::new(0, 0, 0, 0);

       // 1. Проецируем все сумки на сетку (создаем валидные слоты)
       for (bag_entity, bag_pos, bag_rot, bag) in q_bags.iter() {
           let shape = rotate_shape(&bag.provided_slots, bag_rot.0);
           for offset in shape {
               let slot_pos = bag_pos.0 + offset;
               // Если сумки перекрываются, последняя "побеждает".
               // В идеале можно добавить логику запрета перекрытия сумок.
               self.slots.insert(slot_pos, SlotData {
                   bag_entity,
                   occupier: None,
               });
               // Расширяем границы сетки
               self.bounds.max = self.bounds.max.max(slot_pos);
               self.bounds.min = self.bounds.min.min(slot_pos);
           }
       }

       // 2. Размещаем предметы в слотах
       for (item_entity, item_pos, item_rot, item) in q_items.iter() {
           let shape = rotate_shape(&item.shape, item_rot.0);
           for offset in shape {
               let cell_pos = item_pos.0 + offset;
               if let Some(slot) = self.slots.get_mut(&cell_pos) {
                   if slot.occupier.is_some() {
                       warn!("Коллизия! Клетка {:?} уже занята предметом {:?}.", cell_pos, slot.occupier);
                   }
                   slot.occupier = Some(item_entity);
               } else {
                   // Предмет висит в воздухе (вне сумки).
                   // В момент rebuild это считается невалидным состоянием, но мы не удаляем предмет,
                   // чтобы избежать потери данных при багах.
               }
           }
       }
   }

   /// Проверяет, можно ли разместить ПРЕДМЕТ в заданных координатах.
   pub fn can_place_item(
       &self,
       shape: &Vec<IVec2>,
       pos: IVec2,
       rot: u8,
       exclude_entity: Option<Entity>,
       target_is_storage: bool,
   ) -> bool {
       // В хранилище (Storage) всегда можно класть (упрощение: бесконечная емкость).
       if target_is_storage {
           return true; 
       }

       let rotated_shape = rotate_shape(shape, rot);
       for offset in rotated_shape {
           let target_pos = pos + offset;
           match self.slots.get(&target_pos) {
               Some(slot) => {
                   // Слот существует (лежит на сумке). Проверяем занятость.
                   if let Some(occupier) = slot.occupier {
                       // Если занято не нами самими - это коллизия.
                       if Some(occupier)!= exclude_entity {
                           return false; 
                       }
                   }
               },
               None => return false, // Нет сумки под предметом -> Нельзя положить.
           }
       }
       true
   }

   /// Проверяет, можно ли разместить СУМКУ. Сумки не должны перекрывать друг друга.
   pub fn can_place_bag(
       &self,
       bag_shape: &Vec<IVec2>,
       pos: IVec2,
       rot: u8,
       exclude_bag: Option<Entity>,
   ) -> bool {
       let rotated_shape = rotate_shape(bag_shape, rot);
       for offset in rotated_shape {
           let target_pos = pos + offset;
           if let Some(slot) = self.slots.get(&target_pos) {
               if Some(slot.bag_entity)!= exclude_bag {
                   return false; // Наехали на другую сумку
               }
           }
       }
       true
   }
   
   // Хелпер для ИИ/Магазина: Найти первое свободное место
   pub fn find_free_spot(&self, def: &ItemDefinition) -> Option<IVec2> {
       let min = self.bounds.min;
       let max = self.bounds.max;
       for y in min.y..=max.y {
           for x in min.x..=max.x {
               let pos = IVec2::new(x, y);
               // Пробуем с нулевым поворотом
               if self.can_place_item(&def.shape, pos, 0, None, false) {
                   return Some(pos);
               }
           }
       }
       None
   }
}

/// Математика вращения векторов на дискретной сетке (90 град CW)
fn rotate_shape(shape: &Vec<IVec2>, rot: u8) -> Vec<IVec2> {
   let steps = rot % 4;
   if steps == 0 { return shape.clone(); }
   shape.iter().map(|p| {
       let mut v = *p;
       for _ in 0..steps {
           // Формула поворота на 90 град по часовой стрелке в экранных координатах (Y вниз):
           // (x, y) -> (-y, x)
           v = IVec2::new(-v.y, v.x);
       }
       v
   }).collect()
}

// Хелпер для вычисления Bounding Box в пикселях (для спавна)
fn calculate_bounding_box(shape: &Vec<IVec2>, rotation_step: u8) -> (i32, i32, i32, i32) {
   let rotated_shape = rotate_shape(shape, rotation_step);
   if rotated_shape.is_empty() { return (0, 0, 1, 1); }
   let min_x = rotated_shape.iter().map(|v| v.x).min().unwrap();
   let max_x = rotated_shape.iter().map(|v| v.x).max().unwrap();
   let min_y = rotated_shape.iter().map(|v| v.y).min().unwrap();
   let max_y = rotated_shape.iter().map(|v| v.y).max().unwrap();
   (min_x, min_y, max_x - min_x + 1, max_y - min_y + 1)
}

// ============================================================================
// СИСТЕМА ВЗАИМОДЕЙСТВИЯ (BEVY PICKING OBSERVERS)
// ============================================================================

/// Начало перетаскивания (ЛКМ нажат)
fn on_drag_start(
   trigger: Trigger<Pointer<DragStart>>,
   mut commands: Commands,
   q_items: Query<(Entity, &GridPosition, &ItemRotation, Option<&Bag>, Has<InStorage>), With<InventoryItem>>,
   mut drag_state: ResMut<DragState>,
   mut q_node: Query<(&mut ZIndex, &Node)>,
   grid_state: Res<InventoryGridState>,
) {
   let entity = trigger.entity();
   if let Ok((_e, grid_pos, rot, is_bag, in_storage)) = q_items.get(entity) {
       // 1. Сохраняем состояние для отката (Undo)
       drag_state.original_pos = Some(grid_pos.0);
       drag_state.original_rotation = Some(rot.0);
       drag_state.was_in_storage = in_storage;
       drag_state.attached_items.clear();

       // 2. ЛОГИКА КИНЕМАТИКИ СУМОК (Bag Dragging)
       if is_bag.is_some() &&!in_storage {
           // Ищем все предметы, которые лежат в слотах этой сумки
           for (_slot_pos, slot_data) in &grid_state.slots {
               if slot_data.bag_entity == entity {
                   if let Some(occupier) = slot_data.occupier {
                       if!drag_state.attached_items.contains(&occupier) {
                           drag_state.attached_items.push(occupier);
                       }
                   }
               }
           }
       }

       // 3. Визуальный фидбек: Поднимаем предмет над всем UI (GlobalZIndex 100)
       // Важно: Мы используем обычный ZIndex внутри контейнера, но для перекрытия всего
       // можно использовать GlobalZIndex, если родительский контейнер имеет низкий Z.
       // Здесь мы просто ставим высокий локальный ZIndex.
       if let Ok((mut z_index, _)) = q_node.get_mut(entity) {
           *z_index = ZIndex(100); 
       }
       
       // 4. КРИТИЧЕСКИ ВАЖНО: Игнорируем Picking для самого предмета во время драга.
       // Это позволяет лучу мыши "пробивать" предмет насквозь и видеть сетку под ним.
       commands.entity(entity).insert(PickingBehavior::IGNORE);
   }
}

/// Процесс перетаскивания (движение мыши) - обновляем только визуал
fn on_drag(
   trigger: Trigger<Pointer<Drag>>,
   mut q_node: Query<&mut Node>,
) {
   let entity = trigger.entity();
   let drag_event = trigger.event();
   if let Ok(mut node) = q_node.get_mut(entity) {
       // Обновляем визуальные координаты (Style). Логические (GridPosition) не трогаем.
       if let Val::Px(left) = node.left {
           node.left = Val::Px(left + drag_event.delta.x);
       }
       if let Val::Px(top) = node.top {
           node.top = Val::Px(top + drag_event.delta.y);
       }
   }
}

/// Завершение перетаскивания (ЛКМ отпущен) - основная логика
fn on_drag_end(
   trigger: Trigger<Pointer<DragEnd>>,
   mut commands: Commands,
   // Используем ParamSet для разрешения конфликтов заимствования
   mut queries: ParamSet<(
       Query<(Entity, &mut GridPosition, &mut ItemRotation, &InventoryItem, &Node, Option<&Bag>, Has<InStorage>)>, // Mutable
       (
           Query<(Entity, &GridPosition, &ItemRotation, &Bag), Without<InStorage>>, // Bags Read-Only
           Query<(Entity, &GridPosition, &ItemRotation, &InventoryItem), (Without<Bag>, Without<InStorage>)> // Items Read-Only
       )
   )>,
   mut grid_state: ResMut<InventoryGridState>,
   drag_state: Res<DragState>,
   mut ev_changed: EventWriter<InventoryChangedEvent>,
) {
   let entity = trigger.entity();
   
   // 1. Возвращаем интерактивность предмету
   commands.entity(entity).insert(PickingBehavior::default());

   let mut success = false;
   let mut delta = IVec2::ZERO;

   // Scope для мутабельного доступа
   {
       let mut q_mutable = queries.p0();
       if let Ok((_, mut grid_pos, mut rot, item_def, node, is_bag, _)) = q_mutable.get_mut(entity) {
           // 2. Рассчет координат привязки (Snapping)
           // Преобразуем координаты UI Node в индексы сетки.
           let current_left = if let Val::Px(v) = node.left { v } else { 0.0 };
           let current_top = if let Val::Px(v) = node.top { v } else { 0.0 };
           
           // Определяем, находится ли мышь над зоной Хранилища (хардкод порога по Y)
           let is_storage_drop = current_top > 400.0; 

           let target_x = (current_left / TOTAL_CELL_SIZE).round() as i32;
           let target_y = (current_top / TOTAL_CELL_SIZE).round() as i32;
           let target_pos = IVec2::new(target_x, target_y);

           // 3. Валидация
           let mut valid = false;
           if is_storage_drop {
               // Логика сброса в хранилище (всегда разрешено)
               commands.entity(entity).insert(InStorage);
               valid = true;
           } else {
               // Если были в хранилище, убираем компонент
               commands.entity(entity).remove::<InStorage>();
               
               if let Some(bag) = is_bag {
                   // Перемещение Сумки: Проверяем, не наезжает ли она на другие сумки
                   if grid_state.can_place_bag(&bag.provided_slots, target_pos, rot.0, Some(entity)) {
                       valid = true;
                   }
               } else {
                   // Перемещение Предмета: Проверяем, попадает ли он в слоты сумок
                   if grid_state.can_place_item(&item_def.shape, target_pos, rot.0, Some(entity), false) {
                       valid = true;
                   }
               }
           }

           // 4. Применение или Откат
           if valid {
               // УСПЕХ
               // Если мы двигали сумку, вычисляем дельту для вложенных предметов
               if is_bag.is_some() &&!is_storage_drop {
                   delta = target_pos - drag_state.original_pos.unwrap_or(target_pos);
               }
               grid_pos.0 = target_pos;
               ev_changed.send(InventoryChangedEvent);
               success = true;
           } else {
               // ОТКАТ
               if let Some(orig) = drag_state.original_pos {
                   grid_pos.0 = orig;
               }
               if let Some(orig_rot) = drag_state.original_rotation {
                   rot.0 = orig_rot;
               }
               // Возврат флага InStorage
               if drag_state.was_in_storage {
                   commands.entity(entity).insert(InStorage);
               } else {
                   commands.entity(entity).remove::<InStorage>();
               }
           }
       }
   }

   // Обработка "пассажиров" (предметов внутри сумки)
   if success && delta!= IVec2::ZERO {
       let mut q_mutable = queries.p0();
       for attached_entity in &drag_state.attached_items {
           if let Ok((_, mut item_pos, _, _, _, _, _)) = q_mutable.get_mut(*attached_entity) {
               item_pos.0 += delta;
           }
       }
   }

   // 5. Перестройка состояния сетки для следующего кадра
   let (q_bags, q_items) = queries.p1();
   grid_state.rebuild(&q_bags, &q_items);
}

// ============================================================================
// ВИЗУАЛЬНАЯ СИНХРОНИЗАЦИЯ
// ============================================================================

/// Синхронизирует позицию UI Node с логической GridPosition.
/// Работает каждый кадр, обеспечивая плавность и коррекцию после Drop.
fn update_grid_visuals(
   mut q_items: Query<(Entity, &GridPosition, &mut Node, &mut ZIndex, Option<&PickingBehavior>), (With<InventoryItem>, Changed<GridPosition>)>,
) {
   for (_entity, pos, mut node, mut z_index, picking) in q_items.iter_mut() {
       // Не трогаем позицию, если предмет прямо сейчас перетаскивается
       if let Some(behavior) = picking {
           if *behavior == PickingBehavior::IGNORE {
               continue;
           }
       }
       
       // Жесткая привязка к сетке (Snapping)
       node.left = Val::Px(pos.0.x as f32 * TOTAL_CELL_SIZE);
       node.top = Val::Px(pos.0.y as f32 * TOTAL_CELL_SIZE);
       
       // Сброс Z-Index на нормальный уровень
       *z_index = ZIndex(10);
   }
}

/// Обработка вращения клавишей R
fn handle_keyboard_rotation(
   input: Res<ButtonInput<KeyCode>>,
   mut q_items: Query<(&mut ItemRotation, &mut Node, &PickingBehavior)>,
) {
   if input.just_pressed(KeyCode::KeyR) {
       for (mut rot, mut node, behavior) in q_items.iter_mut() {
           // Вращаем только тот предмет, который сейчас тащим
           if *behavior == PickingBehavior::IGNORE {
               rot.0 = (rot.0 + 1) % 4;
               // Визуальный поворот: меняем ширину и высоту местами
               let temp = node.width;
               node.width = node.height;
               node.height = temp;
           }
       }
   }
}

// ============================================================================
// ИНИЦИАЛИЗАЦИЯ UI
// ============================================================================

fn setup_inventory_ui(mut commands: Commands) {
   // Корневой контейнер
   commands.spawn((
       Node {
           width: Val::Percent(100.0),
           height: Val::Percent(100.0),
           justify_content: JustifyContent::FlexStart, // Сверху вниз
           align_items: AlignItems::Center,
           flex_direction: FlexDirection::Column,
          ..default()
       },
       InventoryRoot,
   )).with_children(|parent| {
       // 1. Активная зона инвентаря (где сумки)
       parent.spawn((
           Node {
               width: Val::Px(800.0),
               height: Val::Px(400.0),
               position_type: PositionType::Relative,
               border: UiRect::all(Val::Px(2.0)),
               margin: UiRect::bottom(Val::Px(20.0)),
              ..default()
           },
           InventoryGridContainer,
           BackgroundColor(Color::srgb(0.2, 0.2, 0.2)),
       ));

       // 2. Зона Хранилища (Limbo / Storage)
       parent.spawn((
           Node {
               width: Val::Px(800.0),
               height: Val::Px(200.0),
               position_type: PositionType::Relative,
               border: UiRect::all(Val::Px(2.0)),
              ..default()
           },
           StorageContainer,
           BackgroundColor(Color::srgb(0.15, 0.15, 0.25)), // Чуть синее
       )).with_children(|p| {
           p.spawn((
               Text::new("STORAGE (LIMBO)"),
               TextFont { font_size: 20.0,..default() },
               TextColor(Color::WHITE),
               Node {
                   position_type: PositionType::Absolute,
                   top: Val::Px(5.0),
                   left: Val::Px(5.0),
                  ..default()
               },
           ));
       });
   });
}

fn cleanup_inventory(mut commands: Commands, q: Query<Entity, With<InventoryRoot>>) {
   for e in q.iter() {
       commands.entity(e).despawn_recursive();
   }
}

fn debug_grid_gizmos(_gizmos: Gizmos) {}

// Хелпер для спавна (используется при загрузке и в магазине)
pub fn spawn_item_entity(
   commands: &mut Commands,
   container: Entity,
   def: &ItemDefinition,
   pos: IVec2,
   rotation: u8,
   _grid_state: &mut InventoryGridState,
) {
   let (_min_x, _min_y, width_slots, height_slots) = calculate_bounding_box(&def.shape, rotation);
   let width_px = width_slots as f32 * 64.0;
   let height_px = height_slots as f32 * 64.0;
   
   let left = pos.x as f32 * 64.0;
   let top = pos.y as f32 * 64.0;

   let is_bag = matches!(def.item_type, ItemType::Bag {.. });
   let z_idx = if is_bag { ZIndex(1) } else { ZIndex(10) };
   let bg_color = if is_bag { Color::srgb(0.4, 0.2, 0.1) } else { Color::srgb(0.5, 0.5, 0.8) };

   let mut entity_cmds = commands.spawn((
       Node {
           width: Val::Px(width_px),
           height: Val::Px(height_px),
           position_type: PositionType::Absolute,
           left: Val::Px(left),
           top: Val::Px(top),
           border: UiRect::all(Val::Px(1.0)),
          ..default()
       },
       BackgroundColor(bg_color),
       InventoryItem {
           item_id: def.id.clone(),
           shape: def.shape.clone(),
       },
       GridPosition(pos),
       ItemRotation(rotation),
       z_idx,
       PickingBehavior::default(),
   ));

   if is_bag {
       entity_cmds.insert(Bag { provided_slots: def.shape.clone() });
   }

   // Текст названия
   entity_cmds.with_children(|parent| {
       parent.spawn((
           Text::new(&def.name),
           TextFont { font_size: 14.0,..default() },
           TextColor(Color::WHITE),
           Node {
               position_type: PositionType::Absolute,
               left: Val::Px(2.0),
               top: Val::Px(2.0),
              ..default()
           },
           PickingBehavior::IGNORE, // Текст не должен блокировать драг
       ));
   });

   let entity = entity_cmds.id();
   commands.entity(container).add_child(entity);
}

// Заглушка для боевой статистики
pub struct CombatStats { pub attack: f32, pub defense: f32, pub speed: f32, pub health: f32 }
pub fn calculate_combat_stats(_inv: &crate::plugins::metagame::PersistentInventory, _db: &crate::plugins::items::ItemDatabase) -> CombatStats {
   CombatStats { attack: 10.0, defense: 5.0, speed: 5.0, health: 100.0 }
}

5.2. Модуль определений: src/plugins/items.rs
Здесь мы гарантируем, что ItemDefinition включает поле shape, необходимое для Тетрис-логики.


Rust




use bevy::prelude::*;
use bevy::utils::HashMap;
use serde::Deserialize;

#
pub struct ItemDatabase {
   pub items: HashMap<String, ItemDefinition>,
   pub recipes: Vec<RecipeDefinition>,
}

#
pub struct RecipeDefinition {
   pub ingredients: Vec<String>,
   pub result: String,
   #[serde(default)]
   pub catalysts: Vec<String>,
}

#
pub struct ItemDefinition {
   pub id: String,
   pub name: String,
   pub width: u8,
   pub height: u8,
   // Важное поле: форма предмета в виде списка векторов
   #[serde(default)] 
   pub shape: Vec<IVec2>, 
   #[allow(dead_code)]
   pub material: MaterialType,
   #[allow(dead_code)]
   pub item_type: ItemType,
   #[serde(default)]
   pub rarity: ItemRarity,
   #[serde(default)]
   pub price: u32,
   #[serde(default)]
   pub tags: Vec<ItemTag>,
   #[serde(default)]
   pub synergies: Vec<SynergyDefinition>,
   #[serde(default)] pub attack: f32,
   #[serde(default)] pub defense: f32,
   #[serde(default)] pub speed: f32,
}

//... (остальные Enum'ы: ItemRarity, ItemTag, SynergyDefinition, SynergyEffect, StatType, MaterialType, BagType)
// Копируем их из архива без изменений, они корректны.

pub struct ItemsPlugin;
impl Plugin for ItemsPlugin {
   fn build(&self, app: &mut App) {
       app.init_resource::<ItemDatabase>()
         .add_systems(Startup, load_items);
   }
}

fn load_items(mut item_db: ResMut<ItemDatabase>) {
   let mut items = vec!, // Будет заполнено автогенерацией
           material: MaterialType::Steel,
           item_type: ItemType::Weapon,
           price: 5,
           tags: vec!,
           attack: 10.0,..default()
       },
       //... (остальные предметы, включая сумки)
       ItemDefinition {
           id: "starter_bag".to_string(),
           name: "Starter Bag".to_string(),
           width: 3, height: 3,
           shape: vec!,
           material: MaterialType::Flesh,
           item_type: ItemType::Bag { bag_type: BagType::Default },
           price: 0,
          ..default()
       },
   ];

   // Автогенерация прямоугольных форм, если shape пуст
   for item in items.iter_mut() {
       if item.shape.is_empty() {
           for y in 0..item.height {
               for x in 0..item.width {
                   item.shape.push(IVec2::new(x as i32, y as i32));
               }
           }
       }
   }

   for item in items {
       item_db.items.insert(item.id.clone(), item);
   }
}

5.3. Модуль Метагейма и Сохранений: src/plugins/metagame.rs
Критическое изменение: сохранение поля rotation.


Rust




use bevy::prelude::*;
use serde::{Deserialize, Serialize};
use crate::plugins::core::GameState; // И другие импорты...

#
pub struct SaveData {
   pub player_stats: PlayerStats,
   pub global_time: GlobalTime,
   pub inventory: Vec<SavedItem>,
}

#
pub struct SavedItem {
   pub item_id: String,
   pub grid_x: i32,
   pub grid_y: i32,
   #[serde(default)]
   pub rotation: u8, // Добавлено сохранение поворота
}

//... (Остальной код плагина MetagamePlugin, PlayerStats и т.д. без изменений)

// Обновленная функция создания сохранения
pub fn create_save_data(
   player_stats: &PlayerStats,
   global_time: &GlobalTime,
   q_items: &Query<(&crate::plugins::inventory::InventoryItem, &crate::plugins::inventory::GridPosition, &crate::plugins::inventory::ItemRotation)>,
) -> SaveData {
   let mut saved_items = Vec::new();
   for (item, pos, rot) in q_items.iter() {
       saved_items.push(SavedItem {
           item_id: item.item_id.clone(),
           grid_x: pos.0.x,
           grid_y: pos.0.y,
           rotation: rot.0,
       });
   }
   SaveData {
       player_stats: player_stats.clone(),
       global_time: global_time.clone(),
       inventory: saved_items,
   }
}

6. Протокол интеграции для AI-Агента
Для успешного внедрения представленной архитектуры в проект, AI-агент должен выполнить следующую последовательность действий:
1. Верификация зависимостей: Убедиться, что в Cargo.toml указана версия bevy = "0.15" и включен функционал bevy_picking (он входит в стандартный набор плагинов, но конфигурация может отключать его).
2. Очистка: Полностью удалить содержимое файла src/plugins/inventory.rs. Старая логика несовместима с новой архитектурой "Slot Provider".
3. Замена ядра: Вставить предоставленный код в src/plugins/inventory.rs.
4. Обновление структур: Обновить src/plugins/items.rs и src/plugins/metagame.rs, добавив поддержку поля shape (векторная форма) и rotation (сохранение поворота).
5. Настройка UI: В файле src/plugins/ui.rs убедиться, что корневой узел HUD (Head-Up Display) имеет компонент PickingBehavior::IGNORE и высокий ZIndex(200). Это необходимо, чтобы элементы интерфейса рисовались поверх инвентаря, но не блокировали клики по сетке.
6. Компиляция и Тестирование:
   * Запустить проект (cargo run).
   * Перейти в фазу инвентаря (EveningPhase).
   * Проверить Drag&Drop сумок (предметы внутри должны двигаться синхронно).
   * Проверить вращение предметов клавишей 'R'.
   * Проверить сброс предметов в зону Storage (внизу экрана).
Внедрение этой спецификации трансформирует сломанный прототип в полноценную систему инвентаря, соответствующую стандартам жанра и обеспечивающую масштабируемость для дальнейшей разработки (добавление синергий, крафта и сложных форм сумок).
Источники
1. full_code_archive.txt
2. Game Mechanics - The Backpack Battles Wiki, дата последнего обращения: января 6, 2026, https://backpackbattles.wiki.gg/wiki/Game_Mechanics
3. GlobalZIndex in bevy::ui::prelude - Rust - Docs.rs, дата последнего обращения: января 6, 2026, https://docs.rs/bevy/latest/bevy/ui/prelude/struct.GlobalZIndex.html
4. Bevy Picking | Tainted Coders, дата последнего обращения: января 6, 2026, https://taintedcoders.com/bevy/picking
5. Items (demo) - The Backpack Battles Wiki, дата последнего обращения: января 6, 2026, https://backpackbattles.wiki.gg/wiki/Items_(demo)
6. Bevy rotation in 2D - Stack Overflow, дата последнего обращения: января 6, 2026, https://stackoverflow.com/questions/65370874/bevy-rotation-in-2d
7. Question about bags with "items inside" : r/BackpackBattles - Reddit, дата последнего обращения: января 6, 2026, https://www.reddit.com/r/BackpackBattles/comments/17u77pg/question_about_bags_with_items_inside/
8. Bevy 0.15, дата последнего обращения: января 6, 2026, https://bevy.org/news/bevy-0-15/
9. Showcases simple picking events and usage - Bevy Engine, дата последнего обращения: января 6, 2026, https://bevy.org/examples/picking/simple-picking/