
==================================================
ФАЙЛ: .gitignore
==================================================

/target


==================================================
ФАЙЛ: AGENTS.md
==================================================

# Cursed Warden (Проклятый Страж) - Development Guide

## Overview
**The Cursed Warden** is a Narrative Roguelite / Auto-Battler with an "Inventory Tetris" mechanic, built using the **Bevy Game Engine** (Rust).

## Documentation
* **GDD (Game Design Document):** Located in `docs/` folder. Please refer to this for all gameplay logic, formulas, and architectural decisions.

## Technical Stack
* **Language:** Rust
* **Engine:** Bevy (latest stable)
* **Architecture:** ECS (Entity Component System), Plugin-based.

## Setup Instructions

### 1. Prerequisites

#### Windows (User Environment)
1.  **Install Rust:** Download and install `rustup` from [rust-lang.org](https://www.rust-lang.org/tools/install).
2.  **Install C++ Build Tools:** Install "Desktop development with C++" via Visual Studio Installer (required for Rust linker).
3.  **Optimization (Optional but Recommended):** Install the `lld` linker for faster builds.
    *   `cargo install -f cargo-binutils`
    *   `rustup component add llvm-tools-preview`

#### Linux (Dev/Sandbox Environment)
Bevy requires specific system libraries to interact with the OS (Windowing, Audio, Input).
Ensure the following are installed:
```bash
# Ubuntu/Debian based
sudo apt-get update && sudo apt-get install -y \
    g++ pkg-config libx11-dev libasound2-dev libudev-dev \
    libwayland-dev libxkbcommon-dev
```
*Note: In the sandbox, if `sudo` is unavailable, rely on pre-installed tools or request assistance if builds fail due to missing sys-libs.*

### 2. Running the Project

**Development Mode (Fast Compile):**
We use dynamic linking for development to speed up incremental builds.
```bash
# Run the game
cargo run

# Run with dynamic linking explicitly (if configured in Cargo.toml features)
cargo run --features bevy/dynamic_linking
```

**Release Mode (Optimized):**
```bash
cargo run --release
```

## Project Structure
The project follows a modular plugin architecture as described in the GDD.

```
src/
├── main.rs            # Entry point, App initialization
├── lib.rs             # Lib root, plugin registration
├── core/              # Core systems (AssetLoading, GameState)
├── inventory/         # Grid logic, Tetris mechanics
├── combat/            # Auto-battler simulation
├── meta/              # Time, Economy, Reputation
├── narrative/         # Event system
└── ui/                # UI layout and styling
```

## Development Rules
1.  **Modular Design:** Every major system should be a Bevy `Plugin`.
2.  **ECS First:** Separate Data (Components) from Logic (Systems).
3.  **State Management:** Use `States` to isolate game phases (Day, Evening/Inventory, Night/Combat).
4.  **No Artifacts:** Do not edit files in `target/`.
5.  **Tests:** Write unit tests for complex logic (e.g., inventory overlap checks, damage formulas).

## Troubleshooting
* **"Linking with `cc` failed":** Missing C++ compiler or system libraries. Check Prerequisites.
* **Slow Compile Times:** Ensure you are using the dynamic linking feature during dev.


==================================================
ФАЙЛ: Cargo.lock
==================================================

# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "accesskit"
version = "0.17.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3d3b8f9bae46a948369bc4a03e815d4ed6d616bd00de4051133a5019dc31c5a"

[[package]]
name = "accesskit_consumer"
version = "0.26.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f47983a1084940ba9a39c077a8c63e55c619388be5476ac04c804cfbd1e63459"
dependencies = [
 "accesskit",
 "hashbrown 0.15.5",
 "immutable-chunkmap",
]

[[package]]
name = "accesskit_macos"
version = "0.18.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7329821f3bd1101e03a7d2e03bd339e3ac0dc64c70b4c9f9ae1949e3ba8dece1"
dependencies = [
 "accesskit",
 "accesskit_consumer",
 "hashbrown 0.15.5",
 "objc2 0.5.2",
 "objc2-app-kit",
 "objc2-foundation",
]

[[package]]
name = "accesskit_windows"
version = "0.24.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24fcd5d23d70670992b823e735e859374d694a3d12bfd8dd32bd3bd8bedb5d81"
dependencies = [
 "accesskit",
 "accesskit_consumer",
 "hashbrown 0.15.5",
 "paste",
 "static_assertions",
 "windows 0.58.0",
 "windows-core 0.58.0",
]

[[package]]
name = "accesskit_winit"
version = "0.23.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a6a48dad5530b6deb9fc7a52cc6c3bf72cdd9eb8157ac9d32d69f2427a5e879"
dependencies = [
 "accesskit",
 "accesskit_macos",
 "accesskit_windows",
 "raw-window-handle",
 "winit",
]

[[package]]
name = "adler2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"

[[package]]
name = "ahash"
version = "0.8.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a15f179cd60c4584b8a8c596927aadc462e27f2ca70c04e0071964a73ba7a75"
dependencies = [
 "cfg-if",
 "const-random",
 "getrandom 0.3.4",
 "once_cell",
 "version_check",
 "zerocopy",
]

[[package]]
name = "aho-corasick"
version = "1.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ddd31a130427c27518df266943a5308ed92d4b226cc639f5a8f1002816174301"
dependencies = [
 "memchr",
]

[[package]]
name = "allocator-api2"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "683d7910e743518b0e34f1186f92494becacb047c7b6bf616c96772180fef923"

[[package]]
name = "alsa"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed7572b7ba83a31e20d1b48970ee402d2e3e0537dcfe0a3ff4d6eb7508617d43"
dependencies = [
 "alsa-sys",
 "bitflags 2.10.0",
 "cfg-if",
 "libc",
]

[[package]]
name = "alsa-sys"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db8fee663d06c4e303404ef5f40488a53e062f89ba8bfed81f42325aafad1527"
dependencies = [
 "libc",
 "pkg-config",
]

[[package]]
name = "android-activity"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef6978589202a00cd7e118380c448a08b6ed394c3a8df3a430d0898e3a42d046"
dependencies = [
 "android-properties",
 "bitflags 2.10.0",
 "cc",
 "cesu8",
 "jni",
 "jni-sys",
 "libc",
 "log",
 "ndk 0.9.0",
 "ndk-context",
 "ndk-sys 0.6.0+11769913",
 "num_enum",
 "thiserror",
]

[[package]]
name = "android-properties"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc7eb209b1518d6bb87b283c20095f5228ecda460da70b44f0802523dea6da04"

[[package]]
name = "android_log-sys"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "84521a3cf562bc62942e294181d9eef17eb38ceb8c68677bc49f144e4c3d4f8d"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "approx"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cab112f0a86d568ea0e627cc1d6be74a1e9cd55214684db5561995f6dad897c6"
dependencies = [
 "num-traits",
]

[[package]]
name = "arrayref"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76a2e8124351fda1ef8aaaa3bbd7ebbcb486bbcd4225aca0aa0d84bb2db8fecb"

[[package]]
name = "arrayvec"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"

[[package]]
name = "as-raw-xcb-connection"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "175571dd1d178ced59193a6fc02dde1b972eb0bc56c892cde9beeceac5bf0f6b"

[[package]]
name = "ash"
version = "0.38.0+1.3.281"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0bb44936d800fea8f016d7f2311c6a4f97aebd5dc86f09906139ec848cf3a46f"
dependencies = [
 "libloading",
]

[[package]]
name = "assert_type_match"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f548ad2c4031f2902e3edc1f29c29e835829437de49562d8eb5dc5584d3a1043"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "async-broadcast"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c48ccdbf6ca6b121e0f586cbc0e73ae440e56c67c30fa0873b4e110d9c26d2b"
dependencies = [
 "event-listener 2.5.3",
 "futures-core",
]

[[package]]
name = "async-channel"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "924ed96dd52d1b75e9c1a3e6275715fd320f5f9439fb5a4a11fa51f4221158d2"
dependencies = [
 "concurrent-queue",
 "event-listener-strategy",
 "futures-core",
 "pin-project-lite",
]

[[package]]
name = "async-executor"
version = "1.13.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "497c00e0fd83a72a79a39fcbd8e3e2f055d6f6c7e025f3b3d91f4f8e76527fb8"
dependencies = [
 "async-task",
 "concurrent-queue",
 "fastrand",
 "futures-lite",
 "pin-project-lite",
 "slab",
]

[[package]]
name = "async-fs"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8034a681df4aed8b8edbd7fbe472401ecf009251c8b40556b304567052e294c5"
dependencies = [
 "async-lock",
 "blocking",
 "futures-lite",
]

[[package]]
name = "async-lock"
version = "3.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "290f7f2596bd5b78a9fec8088ccd89180d7f9f55b94b0576823bbbdc72ee8311"
dependencies = [
 "event-listener 5.4.1",
 "event-listener-strategy",
 "pin-project-lite",
]

[[package]]
name = "async-task"
version = "4.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b75356056920673b02621b35afd0f7dda9306d03c79a30f5c56c44cf256e3de"

[[package]]
name = "atomic-waker"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1505bd5d3d116872e7271a6d4e16d81d0c8570876c8de68093a09ac269d8aac0"

[[package]]
name = "atomicow"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f52e8890bb9844440d0c412fa74b67fd2f14e85248b6e00708059b6da9e5f8bf"
dependencies = [
 "portable-atomic",
 "portable-atomic-util",
]

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "base64"
version = "0.21.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "bevy"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2eaad7fe854258047680c51c3cacb804468553c04241912f6254c841c67c0198"
dependencies = [
 "bevy_dylib",
 "bevy_internal",
]

[[package]]
name = "bevy_a11y"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "245a938f754f70a380687b89f1c4dac75b62d58fae90ae969fcfb8ecd91ed879"
dependencies = [
 "accesskit",
 "bevy_app",
 "bevy_derive",
 "bevy_ecs",
 "bevy_reflect",
]

[[package]]
name = "bevy_animation"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41e2b3e4e6cb4df085b941b105f2c790901e34c8571e02342f8e96acdf7cf7d1"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_color",
 "bevy_core",
 "bevy_derive",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_log",
 "bevy_math",
 "bevy_reflect",
 "bevy_render",
 "bevy_time",
 "bevy_transform",
 "bevy_utils",
 "blake3",
 "derive_more",
 "downcast-rs",
 "either",
 "petgraph",
 "ron 0.8.1",
 "serde",
 "smallvec",
 "thread_local",
 "uuid",
]

[[package]]
name = "bevy_app"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a0ac033a388b8699d241499a43783a09e6a3bab2430f1297c6bd4974095efb3f"
dependencies = [
 "bevy_derive",
 "bevy_ecs",
 "bevy_reflect",
 "bevy_tasks",
 "bevy_utils",
 "console_error_panic_hook",
 "ctrlc",
 "derive_more",
 "downcast-rs",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "bevy_asset"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "73fd901b3be016088c4dda2f628bda96b7cb578b9bc8ae684bbf30bec0a9483e"
dependencies = [
 "async-broadcast",
 "async-fs",
 "async-lock",
 "atomicow",
 "bevy_app",
 "bevy_asset_macros",
 "bevy_ecs",
 "bevy_reflect",
 "bevy_tasks",
 "bevy_utils",
 "bevy_window",
 "bitflags 2.10.0",
 "blake3",
 "crossbeam-channel",
 "derive_more",
 "disqualified",
 "downcast-rs",
 "either",
 "futures-io",
 "futures-lite",
 "js-sys",
 "parking_lot",
 "ron 0.8.1",
 "serde",
 "stackfuture",
 "uuid",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
]

[[package]]
name = "bevy_asset_macros"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6725a785789ece8d8c73bba25fdac5e50494d959530e89565bbcea9f808b7181"
dependencies = [
 "bevy_macro_utils",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "bevy_audio"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "30af4b6a91c8e08f623b0cdc53ce5b8f731c78af6ef728cdfc06dc61eda164c4"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_derive",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_math",
 "bevy_reflect",
 "bevy_transform",
 "bevy_utils",
 "cpal",
 "rodio",
]

[[package]]
name = "bevy_color"
version = "0.15.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a87b7137ffa9844ae542043769fb98c35efbf2f8a8429ff2a73d8ef30e58baaa"
dependencies = [
 "bevy_math",
 "bevy_reflect",
 "bytemuck",
 "derive_more",
 "encase",
 "serde",
 "wgpu-types",
]

[[package]]
name = "bevy_core"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e9ce8da8e4016f63c1d361b52e61aaf4348c569829c74f1a5bbedfd8d3d57a3"
dependencies = [
 "bevy_app",
 "bevy_ecs",
 "bevy_reflect",
 "bevy_tasks",
 "bevy_utils",
 "uuid",
]

[[package]]
name = "bevy_core_pipeline"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee0ff0f4723f30a5a6578915dbfe0129f2befaec8438dde70ac1fb363aee01f5"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_color",
 "bevy_core",
 "bevy_derive",
 "bevy_ecs",
 "bevy_image",
 "bevy_math",
 "bevy_reflect",
 "bevy_render",
 "bevy_transform",
 "bevy_utils",
 "bevy_window",
 "bitflags 2.10.0",
 "derive_more",
 "nonmax",
 "radsort",
 "serde",
 "smallvec",
]

[[package]]
name = "bevy_derive"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57d94761ce947b0a2402fd949fe1e7a5b1535293130ba4cd9893be6295d4680a"
dependencies = [
 "bevy_macro_utils",
 "quote",
 "syn",
]

[[package]]
name = "bevy_diagnostic"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e83c65979f063b593917ab9b1d7328c5854dba4b6ddf1ab78156c0105831fdf"
dependencies = [
 "bevy_app",
 "bevy_core",
 "bevy_ecs",
 "bevy_tasks",
 "bevy_time",
 "bevy_utils",
 "const-fnv1a-hash",
 "sysinfo",
]

[[package]]
name = "bevy_dylib"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "381b2a0773cfe9d27256fba1e5005a14968b34f751c09397ee4e278f0fb235db"
dependencies = [
 "bevy_internal",
]

[[package]]
name = "bevy_ecs"
version = "0.15.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ecb64e8f2fe95aa2f8b3e96d09acd23021257ce4a8c942f4c38dcbeaf721955c"
dependencies = [
 "arrayvec",
 "bevy_ecs_macros",
 "bevy_ptr",
 "bevy_reflect",
 "bevy_tasks",
 "bevy_utils",
 "bitflags 2.10.0",
 "concurrent-queue",
 "derive_more",
 "disqualified",
 "fixedbitset 0.5.7",
 "nonmax",
 "petgraph",
 "serde",
 "smallvec",
]

[[package]]
name = "bevy_ecs_macros"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f453adf07712b39826bc5845e5b0887ce03204ee8359bbe6b40a9afda60564a1"
dependencies = [
 "bevy_macro_utils",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "bevy_encase_derive"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f37ad69d36bb9e8479a88d481ef9748f5d7ab676040531d751d3a44441dcede7"
dependencies = [
 "bevy_macro_utils",
 "encase_derive_impl",
]

[[package]]
name = "bevy_gilrs"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a737451ccd6be5da68fbba5d984328b8a82eebd16c1fda0bec840090a3d454fd"
dependencies = [
 "bevy_app",
 "bevy_ecs",
 "bevy_input",
 "bevy_time",
 "bevy_utils",
 "derive_more",
 "gilrs",
]

[[package]]
name = "bevy_gizmos"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1614516d0922ad60e87cc39658422286ed684aaf4b3162d25051bc105eed814"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_color",
 "bevy_core_pipeline",
 "bevy_ecs",
 "bevy_gizmos_macros",
 "bevy_image",
 "bevy_math",
 "bevy_pbr",
 "bevy_reflect",
 "bevy_render",
 "bevy_sprite",
 "bevy_time",
 "bevy_transform",
 "bevy_utils",
 "bytemuck",
]

[[package]]
name = "bevy_gizmos_macros"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0edb9e0dca64e0fc9d6b1d9e6e2178396e339e3e2b9f751e2504e3ea4ddf4508"
dependencies = [
 "bevy_macro_utils",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "bevy_gltf"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa8364f34bc08fe067ce32418e22ee96e177101dbf1bc00803aaeb2b262615be"
dependencies = [
 "base64 0.22.1",
 "bevy_animation",
 "bevy_app",
 "bevy_asset",
 "bevy_color",
 "bevy_core",
 "bevy_core_pipeline",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_image",
 "bevy_math",
 "bevy_pbr",
 "bevy_reflect",
 "bevy_render",
 "bevy_scene",
 "bevy_tasks",
 "bevy_transform",
 "bevy_utils",
 "derive_more",
 "gltf",
 "percent-encoding",
 "serde",
 "serde_json",
 "smallvec",
]

[[package]]
name = "bevy_hierarchy"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19ced04e04437d0a439fe4722544c2a4678c1fe3412b57ee489d817c11884045"
dependencies = [
 "bevy_app",
 "bevy_core",
 "bevy_ecs",
 "bevy_reflect",
 "bevy_utils",
 "disqualified",
 "smallvec",
]

[[package]]
name = "bevy_image"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4b384d1ce9c87f6151292a76233897a628c2a50b3560487c4d74472225d49826"
dependencies = [
 "bevy_asset",
 "bevy_color",
 "bevy_math",
 "bevy_reflect",
 "bevy_utils",
 "bitflags 2.10.0",
 "bytemuck",
 "derive_more",
 "futures-lite",
 "image",
 "ktx2",
 "ruzstd",
 "serde",
 "wgpu",
]

[[package]]
name = "bevy_input"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d52589939ca09695c69d629d166c5edf1759feaaf8f2078904aae9c33d08f5c3"
dependencies = [
 "bevy_app",
 "bevy_core",
 "bevy_ecs",
 "bevy_math",
 "bevy_reflect",
 "bevy_utils",
 "derive_more",
 "smol_str",
]

[[package]]
name = "bevy_internal"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1e0c1d980d276e11558184d0627c8967ad8b70dab3e54a0f377bb53b98515b6"
dependencies = [
 "bevy_a11y",
 "bevy_animation",
 "bevy_app",
 "bevy_asset",
 "bevy_audio",
 "bevy_color",
 "bevy_core",
 "bevy_core_pipeline",
 "bevy_derive",
 "bevy_diagnostic",
 "bevy_ecs",
 "bevy_gilrs",
 "bevy_gizmos",
 "bevy_gltf",
 "bevy_hierarchy",
 "bevy_image",
 "bevy_input",
 "bevy_log",
 "bevy_math",
 "bevy_pbr",
 "bevy_picking",
 "bevy_ptr",
 "bevy_reflect",
 "bevy_render",
 "bevy_scene",
 "bevy_sprite",
 "bevy_state",
 "bevy_tasks",
 "bevy_text",
 "bevy_time",
 "bevy_transform",
 "bevy_ui",
 "bevy_utils",
 "bevy_window",
 "bevy_winit",
]

[[package]]
name = "bevy_log"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b381a22e01f24af51536ef1eace94298dd555d06ffcf368125d16317f5f179cb"
dependencies = [
 "android_log-sys",
 "bevy_app",
 "bevy_ecs",
 "bevy_utils",
 "tracing-log",
 "tracing-oslog",
 "tracing-subscriber",
 "tracing-wasm",
]

[[package]]
name = "bevy_macro_utils"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8bb6ded1ddc124ea214f6a2140e47a78d1fe79b0638dad39419cdeef2e1133f1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "toml_edit 0.22.27",
]

[[package]]
name = "bevy_math"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1c2650169161b64f9a93e41f13253701fdf971dc95265ed667d17bea6d2a334f"
dependencies = [
 "bevy_reflect",
 "derive_more",
 "glam",
 "itertools",
 "rand",
 "rand_distr",
 "serde",
 "smallvec",
]

[[package]]
name = "bevy_mesh"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "760f3c41b4c61a5f0d956537f454c49f79b8ed0fd0781b1a879ead8e69d95283"
dependencies = [
 "bevy_asset",
 "bevy_derive",
 "bevy_ecs",
 "bevy_image",
 "bevy_math",
 "bevy_mikktspace",
 "bevy_reflect",
 "bevy_transform",
 "bevy_utils",
 "bitflags 2.10.0",
 "bytemuck",
 "derive_more",
 "hexasphere",
 "serde",
 "wgpu",
]

[[package]]
name = "bevy_mikktspace"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "226f663401069ded4352ed1472a85bb1f43e2b7305d6a50e53a4f6508168e380"
dependencies = [
 "glam",
]

[[package]]
name = "bevy_pbr"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4d54c840d4352dac51f2a27cf915ac99b2f93db008d8fb1be8d23b09d522acf"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_color",
 "bevy_core_pipeline",
 "bevy_derive",
 "bevy_ecs",
 "bevy_image",
 "bevy_math",
 "bevy_reflect",
 "bevy_render",
 "bevy_transform",
 "bevy_utils",
 "bevy_window",
 "bitflags 2.10.0",
 "bytemuck",
 "derive_more",
 "fixedbitset 0.5.7",
 "nonmax",
 "radsort",
 "smallvec",
 "static_assertions",
]

[[package]]
name = "bevy_picking"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2091a495c0f9c8962abb1e30f9d99696296c332b407e1f6fe1fe28aab96a8629"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_derive",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_input",
 "bevy_math",
 "bevy_mesh",
 "bevy_reflect",
 "bevy_render",
 "bevy_time",
 "bevy_transform",
 "bevy_utils",
 "bevy_window",
 "crossbeam-channel",
 "uuid",
]

[[package]]
name = "bevy_ptr"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89fe0b0b919146939481a3a7c38864face2c6d0fd2c73ab3d430dc693ecd9b11"

[[package]]
name = "bevy_reflect"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3ddbca0a39e88eff2c301dc794ee9d73a53f4b08d47b2c9b5a6aac182fae6217"
dependencies = [
 "assert_type_match",
 "bevy_ptr",
 "bevy_reflect_derive",
 "bevy_utils",
 "derive_more",
 "disqualified",
 "downcast-rs",
 "erased-serde",
 "glam",
 "petgraph",
 "serde",
 "smallvec",
 "smol_str",
 "uuid",
]

[[package]]
name = "bevy_reflect_derive"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d62affb769db17d34ad0b75ff27eca94867e2acc8ea350c5eca97d102bd98709"
dependencies = [
 "bevy_macro_utils",
 "proc-macro2",
 "quote",
 "syn",
 "uuid",
]

[[package]]
name = "bevy_render"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4aa9d7df5c2b65540093b8402aceec0a55d67b54606e57ce2969abe280b4c48"
dependencies = [
 "async-channel",
 "bevy_app",
 "bevy_asset",
 "bevy_color",
 "bevy_core",
 "bevy_derive",
 "bevy_diagnostic",
 "bevy_ecs",
 "bevy_encase_derive",
 "bevy_hierarchy",
 "bevy_image",
 "bevy_math",
 "bevy_mesh",
 "bevy_reflect",
 "bevy_render_macros",
 "bevy_tasks",
 "bevy_time",
 "bevy_transform",
 "bevy_utils",
 "bevy_window",
 "bytemuck",
 "codespan-reporting",
 "derive_more",
 "downcast-rs",
 "encase",
 "futures-lite",
 "image",
 "js-sys",
 "ktx2",
 "naga",
 "naga_oil",
 "nonmax",
 "offset-allocator",
 "send_wrapper",
 "serde",
 "smallvec",
 "wasm-bindgen",
 "web-sys",
 "wgpu",
]

[[package]]
name = "bevy_render_macros"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3469307d1b5ca5c37b7f9269be033845357412ebad33eace46826e59da592f66"
dependencies = [
 "bevy_macro_utils",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "bevy_scene"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bdfe819202aa97bbb206d79fef83504b34d45529810563aafc2fe02cc10e3ee4"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_derive",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_reflect",
 "bevy_render",
 "bevy_transform",
 "bevy_utils",
 "derive_more",
 "serde",
 "uuid",
]

[[package]]
name = "bevy_sprite"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "27411a31704117002787c9e8cc1f2f89babf5e67572508aa029366d4643f8d01"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_color",
 "bevy_core_pipeline",
 "bevy_derive",
 "bevy_ecs",
 "bevy_image",
 "bevy_math",
 "bevy_picking",
 "bevy_reflect",
 "bevy_render",
 "bevy_transform",
 "bevy_utils",
 "bevy_window",
 "bitflags 2.10.0",
 "bytemuck",
 "derive_more",
 "fixedbitset 0.5.7",
 "guillotiere",
 "nonmax",
 "radsort",
 "rectangle-pack",
]

[[package]]
name = "bevy_state"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "243a72266f81452412f7a3859e5d11473952a25767dc29c8d285660330f007ba"
dependencies = [
 "bevy_app",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_reflect",
 "bevy_state_macros",
 "bevy_utils",
]

[[package]]
name = "bevy_state_macros"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "022eb069dfd64090fd92ba4a7f235383e49aa1c0f4320dab4999b23f67843b36"
dependencies = [
 "bevy_macro_utils",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "bevy_tasks"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "028630ddc355563bd567df1076db3515858aa26715ddf7467d2086f9b40e5ab1"
dependencies = [
 "async-channel",
 "async-executor",
 "concurrent-queue",
 "futures-channel",
 "futures-lite",
 "pin-project",
 "wasm-bindgen-futures",
]

[[package]]
name = "bevy_text"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "872b0b627cedf6d1bd97b75bc4d59c16f67afdd4f2fed8f7d808a258d6cb982e"
dependencies = [
 "bevy_app",
 "bevy_asset",
 "bevy_color",
 "bevy_derive",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_image",
 "bevy_math",
 "bevy_reflect",
 "bevy_render",
 "bevy_sprite",
 "bevy_transform",
 "bevy_utils",
 "bevy_window",
 "cosmic-text",
 "derive_more",
 "serde",
 "smallvec",
 "sys-locale",
 "unicode-bidi",
]

[[package]]
name = "bevy_time"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b2051ec56301b994f7c182a2a6eb1490038149ad46d95eee715e1a922acdfd9"
dependencies = [
 "bevy_app",
 "bevy_ecs",
 "bevy_reflect",
 "bevy_utils",
 "crossbeam-channel",
]

[[package]]
name = "bevy_transform"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8109b1234b0e58931f51df12bc8895daa69298575cf92da408848f79a4ce201"
dependencies = [
 "bevy_app",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_math",
 "bevy_reflect",
 "derive_more",
]

[[package]]
name = "bevy_ui"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e534590222d044c875bf3511e5d0b3da78889bb21ad797953484ce011af77b46"
dependencies = [
 "accesskit",
 "bevy_a11y",
 "bevy_app",
 "bevy_asset",
 "bevy_color",
 "bevy_core_pipeline",
 "bevy_derive",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_image",
 "bevy_input",
 "bevy_math",
 "bevy_picking",
 "bevy_reflect",
 "bevy_render",
 "bevy_sprite",
 "bevy_text",
 "bevy_transform",
 "bevy_utils",
 "bevy_window",
 "bytemuck",
 "derive_more",
 "nonmax",
 "smallvec",
 "taffy",
]

[[package]]
name = "bevy_utils"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "63c2174d43a0de99f863c98a472370047a2bfa7d1e5cec8d9d647fb500905d9d"
dependencies = [
 "ahash",
 "bevy_utils_proc_macros",
 "getrandom 0.2.16",
 "hashbrown 0.14.5",
 "thread_local",
 "tracing",
 "web-time",
]

[[package]]
name = "bevy_utils_proc_macros"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94847541f6dd2e28f54a9c2b0e857da5f2631e2201ebc25ce68781cdcb721391"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "bevy_window"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1e1e7c6713c04404a3e7cede48a9c47b76c30efc764664ec1246147f6fb9878"
dependencies = [
 "android-activity",
 "bevy_a11y",
 "bevy_app",
 "bevy_ecs",
 "bevy_input",
 "bevy_math",
 "bevy_reflect",
 "bevy_utils",
 "raw-window-handle",
 "smol_str",
]

[[package]]
name = "bevy_winit"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e158a73d6d896b1600a61bc115017707ecb467d1a5ad49231c5e58294f6f6e13"
dependencies = [
 "accesskit",
 "accesskit_winit",
 "approx",
 "bevy_a11y",
 "bevy_app",
 "bevy_asset",
 "bevy_derive",
 "bevy_ecs",
 "bevy_hierarchy",
 "bevy_image",
 "bevy_input",
 "bevy_log",
 "bevy_math",
 "bevy_reflect",
 "bevy_tasks",
 "bevy_utils",
 "bevy_window",
 "bytemuck",
 "cfg-if",
 "crossbeam-channel",
 "raw-window-handle",
 "wasm-bindgen",
 "web-sys",
 "wgpu-types",
 "winit",
]

[[package]]
name = "bindgen"
version = "0.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f49d8fed880d473ea71efb9bf597651e77201bdd4893efe54c9e5d65ae04ce6f"
dependencies = [
 "bitflags 2.10.0",
 "cexpr",
 "clang-sys",
 "itertools",
 "log",
 "prettyplease",
 "proc-macro2",
 "quote",
 "regex",
 "rustc-hash 1.1.0",
 "shlex",
 "syn",
]

[[package]]
name = "bindgen"
version = "0.72.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "993776b509cfb49c750f11b8f07a46fa23e0a1386ffc01fb1e7d343efc387895"
dependencies = [
 "bitflags 2.10.0",
 "cexpr",
 "clang-sys",
 "itertools",
 "proc-macro2",
 "quote",
 "regex",
 "rustc-hash 2.1.1",
 "shlex",
 "syn",
]

[[package]]
name = "bit-set"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0700ddab506f33b20a03b13996eccd309a48e5ff77d0d95926aa0210fb4e95f1"
dependencies = [
 "bit-vec 0.6.3",
]

[[package]]
name = "bit-set"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08807e080ed7f9d5433fa9b275196cfc35414f66a0c79d864dc51a0d825231a3"
dependencies = [
 "bit-vec 0.8.0",
]

[[package]]
name = "bit-vec"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "349f9b6a179ed607305526ca489b34ad0a41aed5f7980fa90eb03160b69598fb"

[[package]]
name = "bit-vec"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e764a1d40d510daf35e07be9eb06e75770908c27d411ee6c92109c9840eaaf7"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "812e12b5285cc515a9c72a5c1d3b6d46a19dac5acfef5265968c166106e31dd3"
dependencies = [
 "serde_core",
]

[[package]]
name = "blake3"
version = "1.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3888aaa89e4b2a40fca9848e400f6a658a5a3978de7be858e209cafa8be9a4a0"
dependencies = [
 "arrayref",
 "arrayvec",
 "cc",
 "cfg-if",
 "constant_time_eq",
]

[[package]]
name = "block"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d8c1fef690941d3e7788d328517591fecc684c084084702d6ff1641e993699a"

[[package]]
name = "block2"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c132eebf10f5cad5289222520a4a058514204aed6d791f1cf4fe8088b82d15f"
dependencies = [
 "objc2 0.5.2",
]

[[package]]
name = "block2"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cdeb9d870516001442e364c5220d3574d2da8dc765554b4a617230d33fa58ef5"
dependencies = [
 "objc2 0.6.3",
]

[[package]]
name = "blocking"
version = "1.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e83f8d02be6967315521be875afa792a316e28d57b5a2d401897e2a7921b7f21"
dependencies = [
 "async-channel",
 "async-task",
 "futures-io",
 "futures-lite",
 "piper",
]

[[package]]
name = "bumpalo"
version = "3.19.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5dd9dc738b7a8311c7ade152424974d8115f2cdad61e8dab8dac9f2362298510"

[[package]]
name = "bytemuck"
version = "1.24.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fbdf580320f38b612e485521afda1ee26d10cc9884efaaa750d383e13e3c5f4"
dependencies = [
 "bytemuck_derive",
]

[[package]]
name = "bytemuck_derive"
version = "1.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9abbd1bc6865053c427f7198e6af43bfdedc55ab791faed4fbd361d789575ff"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "byteorder-lite"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f1fe948ff07f4bd06c30984e69f5b4899c516a3ef74f34df92a2df2ab535495"

[[package]]
name = "bytes"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b35204fbdc0b3f4446b89fc1ac2cf84a8a68971995d0bf2e925ec7cd960f9cb3"

[[package]]
name = "calloop"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b99da2f8558ca23c71f4fd15dc57c906239752dd27ff3c00a1d56b685b7cbfec"
dependencies = [
 "bitflags 2.10.0",
 "log",
 "polling",
 "rustix 0.38.44",
 "slab",
 "thiserror",
]

[[package]]
name = "cc"
version = "1.2.51"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a0aeaff4ff1a90589618835a598e545176939b97874f7abc7851caa0618f203"
dependencies = [
 "find-msvc-tools",
 "jobserver",
 "libc",
 "shlex",
]

[[package]]
name = "cesu8"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d43a04d8753f35258c91f8ec639f792891f748a1edbd759cf1dcea3382ad83c"

[[package]]
name = "cexpr"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
dependencies = [
 "nom",
]

[[package]]
name = "cfg-if"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9330f8b2ff13f34540b44e946ef35111825727b38d33286ef986142615121801"

[[package]]
name = "cfg_aliases"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd16c4719339c4530435d38e511904438d07cce7950afa3718a84ac36c10e89e"

[[package]]
name = "cfg_aliases"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"

[[package]]
name = "clang-sys"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b023947811758c97c59bf9d1c188fd619ad4718dcaa767947df1cadb14f39f4"
dependencies = [
 "glob",
 "libc",
 "libloading",
]

[[package]]
name = "codespan-reporting"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3538270d33cc669650c4b093848450d380def10c331d38c768e34cac80576e6e"
dependencies = [
 "termcolor",
 "unicode-width",
]

[[package]]
name = "combine"
version = "4.6.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba5a308b75df32fe02788e748662718f03fde005016435c444eea572398219fd"
dependencies = [
 "bytes",
 "memchr",
]

[[package]]
name = "concurrent-queue"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ca0197aee26d1ae37445ee532fefce43251d24cc7c166799f4d46817f1d3973"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "console_error_panic_hook"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a06aeb73f470f66dcdbf7223caeebb85984942f22f1adb2a088cf9668146bbbc"
dependencies = [
 "cfg-if",
 "wasm-bindgen",
]

[[package]]
name = "const-fnv1a-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32b13ea120a812beba79e34316b3942a857c86ec1593cb34f27bb28272ce2cca"

[[package]]
name = "const-random"
version = "0.1.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87e00182fe74b066627d63b85fd550ac2998d4b0bd86bfed477a0ae4c7c71359"
dependencies = [
 "const-random-macro",
]

[[package]]
name = "const-random-macro"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9d839f2a20b0aee515dc581a6172f2321f96cab76c1a38a4c584a194955390e"
dependencies = [
 "getrandom 0.2.16",
 "once_cell",
 "tiny-keccak",
]

[[package]]
name = "const_panic"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e262cdaac42494e3ae34c43969f9cdeb7da178bdb4b66fa6a1ea2edb4c8ae652"
dependencies = [
 "typewit",
]

[[package]]
name = "const_soft_float"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87ca1caa64ef4ed453e68bb3db612e51cf1b2f5b871337f0fcab1c8f87cc3dff"

[[package]]
name = "constant_time_eq"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c74b8349d32d297c9134b8c88677813a227df8f779daa29bfc29c183fe3dca6"

[[package]]
name = "constgebra"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1aaf9b65849a68662ac6c0810c8893a765c960b907dd7cfab9c4a50bf764fbc"
dependencies = [
 "const_soft_float",
]

[[package]]
name = "core-foundation"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2a6cd9ae233e7f62ba4e9353e81a88df7fc8a5987b8d445b4d90c879bd156f6"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "core-graphics"
version = "0.23.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c07782be35f9e1140080c6b96f0d44b739e2278479f64e02fdab4e32dfd8b081"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation 0.9.4",
 "core-graphics-types",
 "foreign-types",
 "libc",
]

[[package]]
name = "core-graphics-types"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "45390e6114f68f718cc7a830514a96f903cccd70d02a8f6d9f643ac4ba45afaf"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation 0.9.4",
 "libc",
]

[[package]]
name = "coreaudio-rs"
version = "0.11.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "321077172d79c662f64f5071a03120748d5bb652f5231570141be24cfcd2bace"
dependencies = [
 "bitflags 1.3.2",
 "core-foundation-sys",
 "coreaudio-sys",
]

[[package]]
name = "coreaudio-sys"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ceec7a6067e62d6f931a2baf6f3a751f4a892595bcec1461a3c94ef9949864b6"
dependencies = [
 "bindgen 0.72.1",
]

[[package]]
name = "cosmic-text"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59fd57d82eb4bfe7ffa9b1cec0c05e2fd378155b47f255a67983cb4afe0e80c2"
dependencies = [
 "bitflags 2.10.0",
 "fontdb",
 "log",
 "rangemap",
 "rayon",
 "rustc-hash 1.1.0",
 "rustybuzz",
 "self_cell",
 "swash",
 "sys-locale",
 "ttf-parser 0.21.1",
 "unicode-bidi",
 "unicode-linebreak",
 "unicode-script",
 "unicode-segmentation",
]

[[package]]
name = "cpal"
version = "0.15.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "873dab07c8f743075e57f524c583985fbaf745602acbe916a01539364369a779"
dependencies = [
 "alsa",
 "core-foundation-sys",
 "coreaudio-rs",
 "dasp_sample",
 "jni",
 "js-sys",
 "libc",
 "mach2",
 "ndk 0.8.0",
 "ndk-context",
 "oboe",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "windows 0.54.0",
]

[[package]]
name = "crc32fast"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9481c1c90cbf2ac953f07c8d4a58aa3945c425b7185c9154d67a65e4230da511"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crossbeam-channel"
version = "0.5.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "82b8f8f868b36967f9606790d1903570de9ceaf870a7bf9fbbd3016d636a2cb2"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-deque"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51"
dependencies = [
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"

[[package]]
name = "crunchy"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "460fbee9c2c2f33933d720630a6a0bac33ba7053db5344fac858d4b8952d77d5"

[[package]]
name = "ctrlc"
version = "3.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "73736a89c4aff73035ba2ed2e565061954da00d4970fc9ac25dcc85a2a20d790"
dependencies = [
 "dispatch2",
 "nix",
 "windows-sys 0.61.2",
]

[[package]]
name = "cursed_warden"
version = "0.1.0"
dependencies = [
 "bevy",
 "rand",
 "ron 0.12.0",
 "serde",
 "serde_json",
]

[[package]]
name = "cursor-icon"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f27ae1dd37df86211c42e150270f82743308803d90a6f6e6651cd730d5e1732f"

[[package]]
name = "dasp_sample"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c87e182de0887fd5361989c677c4e8f5000cd9491d6d563161a8f3a5519fc7f"

[[package]]
name = "data-encoding"
version = "2.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a2330da5de22e8a3cb63252ce2abb30116bf5265e89c0e01bc17015ce30a476"

[[package]]
name = "derive_more"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a9b99b9cbbe49445b21764dc0625032a89b145a2642e67603e1c936f5458d05"
dependencies = [
 "derive_more-impl",
]

[[package]]
name = "derive_more-impl"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb7330aeadfbe296029522e6c40f315320aba36fc43a5b3632f3795348f3bd22"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "unicode-xid",
]

[[package]]
name = "dispatch"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd0c93bb4b0c6d9b77f4435b0ae98c24d17f1c45b2ff844c6151a07256ca923b"

[[package]]
name = "dispatch2"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89a09f22a6c6069a18470eb92d2298acf25463f14256d24778e1230d789a2aec"
dependencies = [
 "bitflags 2.10.0",
 "block2 0.6.2",
 "libc",
 "objc2 0.6.3",
]

[[package]]
name = "disqualified"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c9c272297e804878a2a4b707cfcfc6d2328b5bb936944613b4fdf2b9269afdfd"

[[package]]
name = "dlib"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "330c60081dcc4c72131f8eb70510f1ac07223e5d4163db481a04a0befcffa412"
dependencies = [
 "libloading",
]

[[package]]
name = "document-features"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4b8a88685455ed29a21542a33abd9cb6510b6b129abadabdcef0f4c55bc8f61"
dependencies = [
 "litrs",
]

[[package]]
name = "downcast-rs"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75b325c5dbd37f80359721ad39aca5a29fb04c89279657cffdda8736d0c0b9d2"

[[package]]
name = "dpi"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8b14ccef22fc6f5a8f4d7d768562a182c04ce9a3b3157b91390b52ddfdf1a76"

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"

[[package]]
name = "encase"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0a05902cf601ed11d564128448097b98ebe3c6574bd7b6a653a3d56d54aa020"
dependencies = [
 "const_panic",
 "encase_derive",
 "glam",
 "thiserror",
]

[[package]]
name = "encase_derive"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "181d475b694e2dd56ae919ce7699d344d1fd259292d590c723a50d1189a2ea85"
dependencies = [
 "encase_derive_impl",
]

[[package]]
name = "encase_derive_impl"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f97b51c5cc57ef7c5f7a0c57c250251c49ee4c28f819f87ac32f4aceabc36792"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "erased-serde"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89e8918065695684b2b0702da20382d5ae6065cf3327bc2d6436bd49a71ce9f3"
dependencies = [
 "serde",
 "serde_core",
 "typeid",
]

[[package]]
name = "errno"
version = "0.3.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "39cab71617ae0d63f51a36d69f866391735b51691dbda63cf6f96d042b63efeb"
dependencies = [
 "libc",
 "windows-sys 0.61.2",
]

[[package]]
name = "euclid"
version = "0.22.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ad9cdb4b747e485a12abb0e6566612956c7a1bafa3bdb8d682c5b6d403589e48"
dependencies = [
 "num-traits",
]

[[package]]
name = "event-listener"
version = "2.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0206175f82b8d6bf6652ff7d71a1e27fd2e4efde587fd368662814d6ec1d9ce0"

[[package]]
name = "event-listener"
version = "5.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e13b66accf52311f30a0db42147dadea9850cb48cd070028831ae5f5d4b856ab"
dependencies = [
 "concurrent-queue",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "event-listener-strategy"
version = "0.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8be9f3dfaaffdae2972880079a491a1a8bb7cbed0b8dd7a347f668b4150a3b93"
dependencies = [
 "event-listener 5.4.1",
 "pin-project-lite",
]

[[package]]
name = "fastrand"
version = "2.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "37909eebbb50d72f9059c3b6d82c0463f2ff062c9e95845c43a6c9c0355411be"

[[package]]
name = "fdeflate"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e6853b52649d4ac5c0bd02320cddc5ba956bdb407c4b75a2c6b75bf51500f8c"
dependencies = [
 "simd-adler32",
]

[[package]]
name = "find-msvc-tools"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "645cbb3a84e60b7531617d5ae4e57f7e27308f6445f5abf653209ea76dec8dff"

[[package]]
name = "fixedbitset"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ce7134b9999ecaf8bcd65542e436736ef32ddca1b3e06094cb6ec5755203b80"

[[package]]
name = "fixedbitset"
version = "0.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d674e81391d1e1ab681a28d99df07927c6d4aa5b027d7da16ba32d1d21ecd99"

[[package]]
name = "flate2"
version = "1.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfe33edd8e85a12a67454e37f8c75e730830d83e313556ab9ebf9ee7fbeb3bfb"
dependencies = [
 "crc32fast",
 "miniz_oxide",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foldhash"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"

[[package]]
name = "font-types"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b3971f9a5ca983419cdc386941ba3b9e1feba01a0ab888adf78739feb2798492"
dependencies = [
 "bytemuck",
]

[[package]]
name = "fontconfig-parser"
version = "0.5.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbc773e24e02d4ddd8395fd30dc147524273a83e54e0f312d986ea30de5f5646"
dependencies = [
 "roxmltree",
]

[[package]]
name = "fontdb"
version = "0.16.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0299020c3ef3f60f526a4f64ab4a3d4ce116b1acbf24cdd22da0068e5d81dc3"
dependencies = [
 "fontconfig-parser",
 "log",
 "memmap2",
 "slotmap",
 "tinyvec",
 "ttf-parser 0.20.0",
]

[[package]]
name = "foreign-types"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d737d9aa519fb7b749cbc3b962edcf310a8dd1f4b67c91c4f83975dbdd17d965"
dependencies = [
 "foreign-types-macros",
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-macros"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a5c6c585bc94aaf2c7b51dd4c2ba22680844aba4c687be581871a6f518c5742"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "foreign-types-shared"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aa9a19cbb55df58761df49b23516a86d432839add4af60fc256da840f66ed35b"

[[package]]
name = "futures-channel"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
dependencies = [
 "futures-core",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-io"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"

[[package]]
name = "futures-lite"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f78e10609fe0e0b3f4157ffab1876319b5b0db102a2c60dc4626306dc46b44ad"
dependencies = [
 "fastrand",
 "futures-core",
 "futures-io",
 "parking",
 "pin-project-lite",
]

[[package]]
name = "gethostname"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bd49230192a3797a9a4d6abe9b3eed6f7fa4c8a8a4947977c6f80025f92cbd8"
dependencies = [
 "rustix 1.1.3",
 "windows-link",
]

[[package]]
name = "getrandom"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "wasi",
 "wasm-bindgen",
]

[[package]]
name = "getrandom"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "899def5c37c4fd7b2664648c28120ecec138e4d395b459e5ca34f9cce2dd77fd"
dependencies = [
 "cfg-if",
 "libc",
 "r-efi",
 "wasip2",
]

[[package]]
name = "gilrs"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbb2c998745a3c1ac90f64f4f7b3a54219fd3612d7705e7798212935641ed18f"
dependencies = [
 "fnv",
 "gilrs-core",
 "log",
 "uuid",
 "vec_map",
]

[[package]]
name = "gilrs-core"
version = "0.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be11a71ac3564f6965839e2ed275bf4fcf5ce16d80d396e1dfdb7b2d80bd587e"
dependencies = [
 "core-foundation 0.10.1",
 "inotify",
 "io-kit-sys",
 "js-sys",
 "libc",
 "libudev-sys",
 "log",
 "nix",
 "uuid",
 "vec_map",
 "wasm-bindgen",
 "web-sys",
 "windows 0.58.0",
]

[[package]]
name = "gl_generator"
version = "0.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a95dfc23a2b4a9a2f5ab41d194f8bfda3cabec42af4e39f08c339eb2a0c124d"
dependencies = [
 "khronos_api",
 "log",
 "xml-rs",
]

[[package]]
name = "glam"
version = "0.29.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8babf46d4c1c9d92deac9f7be466f76dfc4482b6452fc5024b5e8daf6ffeb3ee"
dependencies = [
 "bytemuck",
 "rand",
 "serde",
]

[[package]]
name = "glob"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cc23270f6e1808e30a928bdc84dea0b9b4136a8bc82338574f23baf47bbd280"

[[package]]
name = "glow"
version = "0.14.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d51fa363f025f5c111e03f13eda21162faeacb6911fe8caa0c0349f9cf0c4483"
dependencies = [
 "js-sys",
 "slotmap",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "gltf"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3ce1918195723ce6ac74e80542c5a96a40c2b26162c1957a5cd70799b8cacf7"
dependencies = [
 "byteorder",
 "gltf-json",
 "lazy_static",
 "serde_json",
]

[[package]]
name = "gltf-derive"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14070e711538afba5d6c807edb74bcb84e5dbb9211a3bf5dea0dfab5b24f4c51"
dependencies = [
 "inflections",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "gltf-json"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6176f9d60a7eab0a877e8e96548605dedbde9190a7ae1e80bbcc1c9af03ab14"
dependencies = [
 "gltf-derive",
 "serde",
 "serde_derive",
 "serde_json",
]

[[package]]
name = "glutin_wgl_sys"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c4ee00b289aba7a9e5306d57c2d05499b2e5dc427f84ac708bd2c090212cf3e"
dependencies = [
 "gl_generator",
]

[[package]]
name = "gpu-alloc"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbcd2dba93594b227a1f57ee09b8b9da8892c34d55aa332e034a228d0fe6a171"
dependencies = [
 "bitflags 2.10.0",
 "gpu-alloc-types",
]

[[package]]
name = "gpu-alloc-types"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "98ff03b468aa837d70984d55f5d3f846f6ec31fe34bbb97c4f85219caeee1ca4"
dependencies = [
 "bitflags 2.10.0",
]

[[package]]
name = "gpu-allocator"
version = "0.27.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c151a2a5ef800297b4e79efa4f4bec035c5f51d5ae587287c9b952bdf734cacd"
dependencies = [
 "log",
 "presser",
 "thiserror",
 "windows 0.58.0",
]

[[package]]
name = "gpu-descriptor"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b89c83349105e3732062a895becfc71a8f921bb71ecbbdd8ff99263e3b53a0ca"
dependencies = [
 "bitflags 2.10.0",
 "gpu-descriptor-types",
 "hashbrown 0.15.5",
]

[[package]]
name = "gpu-descriptor-types"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fdf242682df893b86f33a73828fb09ca4b2d3bb6cc95249707fc684d27484b91"
dependencies = [
 "bitflags 2.10.0",
]

[[package]]
name = "grid"
version = "0.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be136d9dacc2a13cc70bb6c8f902b414fb2641f8db1314637c6b7933411a8f82"

[[package]]
name = "guillotiere"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b62d5865c036cb1393e23c50693df631d3f5d7bcca4c04fe4cc0fd592e74a782"
dependencies = [
 "euclid",
 "svg_fmt",
]

[[package]]
name = "hashbrown"
version = "0.14.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"
dependencies = [
 "ahash",
 "allocator-api2",
 "serde",
]

[[package]]
name = "hashbrown"
version = "0.15.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9229cfe53dfd69f0609a49f65461bd93001ea1ef889cd5529dd176593f5338a1"
dependencies = [
 "foldhash",
]

[[package]]
name = "hashbrown"
version = "0.16.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "841d1cc9bed7f9236f321df977030373f4a4163ae1a7dbfe1a51a2c1a51d9100"

[[package]]
name = "hermit-abi"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc0fef456e4baa96da950455cd02c081ca953b141298e41db3fc7e36b1da849c"

[[package]]
name = "hexasphere"
version = "15.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9c9e718d32b6e6b2b32354e1b0367025efdd0b11d6a740b905ddf5db1074679"
dependencies = [
 "constgebra",
 "glam",
 "tinyvec",
]

[[package]]
name = "hexf-parse"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfa686283ad6dd069f105e5ab091b04c62850d3e4cf5d67debad1933f55023df"

[[package]]
name = "image"
version = "0.25.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6506c6c10786659413faa717ceebcb8f70731c0a60cbae39795fdf114519c1a"
dependencies = [
 "bytemuck",
 "byteorder-lite",
 "moxcms",
 "num-traits",
 "png",
]

[[package]]
name = "immutable-chunkmap"
version = "2.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a3e98b1520e49e252237edc238a39869da9f3241f2ec19dc788c1d24694d1e4"
dependencies = [
 "arrayvec",
]

[[package]]
name = "indexmap"
version = "2.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ad4bb2b565bca0645f4d68c5c9af97fba094e9791da685bf83cb5f3ce74acf2"
dependencies = [
 "equivalent",
 "hashbrown 0.16.1",
]

[[package]]
name = "inflections"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a257582fdcde896fd96463bf2d40eefea0580021c0712a0e2b028b60b47a837a"

[[package]]
name = "inotify"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f37dccff2791ab604f9babef0ba14fbe0be30bd368dc541e2b08d07c8aa908f3"
dependencies = [
 "bitflags 2.10.0",
 "inotify-sys",
 "libc",
]

[[package]]
name = "inotify-sys"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e05c02b5e89bff3b946cedeca278abc628fe811e604f027c45a8aa3cf793d0eb"
dependencies = [
 "libc",
]

[[package]]
name = "io-kit-sys"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "617ee6cf8e3f66f3b4ea67a4058564628cde41901316e19f559e14c7c72c5e7b"
dependencies = [
 "core-foundation-sys",
 "mach2",
]

[[package]]
name = "itertools"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "413ee7dfc52ee1a4949ceeb7dbc8a33f2d6c088194d9f922fb8318faf1f01186"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "92ecc6618181def0457392ccd0ee51198e065e016d1d527a7ac1b6dc7c1f09d2"

[[package]]
name = "jni"
version = "0.21.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a87aa2bb7d2af34197c04845522473242e1aa17c12f4935d5856491a7fb8c97"
dependencies = [
 "cesu8",
 "cfg-if",
 "combine",
 "jni-sys",
 "log",
 "thiserror",
 "walkdir",
 "windows-sys 0.45.0",
]

[[package]]
name = "jni-sys"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8eaf4bc02d17cbdd7ff4c7438cafcdf7fb9a4613313ad11b4f8fefe7d3fa0130"

[[package]]
name = "jobserver"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9afb3de4395d6b3e67a780b6de64b51c978ecf11cb9a462c66be7d4ca9039d33"
dependencies = [
 "getrandom 0.3.4",
 "libc",
]

[[package]]
name = "js-sys"
version = "0.3.83"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "464a3709c7f55f1f721e5389aa6ea4e3bc6aba669353300af094b29ffbdde1d8"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "khronos-egl"
version = "6.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6aae1df220ece3c0ada96b8153459b67eebe9ae9212258bb0134ae60416fdf76"
dependencies = [
 "libc",
 "libloading",
 "pkg-config",
]

[[package]]
name = "khronos_api"
version = "3.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e2db585e1d738fc771bf08a151420d3ed193d9d895a36df7f6f8a9456b911ddc"

[[package]]
name = "ktx2"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87d65e08a9ec02e409d27a0139eaa6b9756b4d81fe7cde71f6941a83730ce838"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "lewton"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "777b48df9aaab155475a83a7df3070395ea1ac6902f5cd062b8f2b028075c030"
dependencies = [
 "byteorder",
 "ogg",
 "tinyvec",
]

[[package]]
name = "libc"
version = "0.2.179"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c5a2d376baa530d1238d133232d15e239abad80d05838b4b59354e5268af431f"

[[package]]
name = "libloading"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d7c4b02199fee7c5d21a5ae7d8cfa79a6ef5bb2fc834d6e9058e89c825efdc55"
dependencies = [
 "cfg-if",
 "windows-link",
]

[[package]]
name = "libm"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9fbbcab51052fe104eb5e5d351cf728d30a5be1fe14d9be8a3b097481fb97de"

[[package]]
name = "libredox"
version = "0.1.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d0b95e02c851351f877147b7deea7b1afb1df71b63aa5f8270716e0c5720616"
dependencies = [
 "bitflags 2.10.0",
 "libc",
 "redox_syscall 0.7.0",
]

[[package]]
name = "libudev-sys"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c8469b4a23b962c1396b9b451dda50ef5b283e8dd309d69033475fa9b334324"
dependencies = [
 "libc",
 "pkg-config",
]

[[package]]
name = "linux-raw-sys"
version = "0.4.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d26c52dbd32dccf2d10cac7725f8eae5296885fb5703b261f7d0a0739ec807ab"

[[package]]
name = "linux-raw-sys"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df1d3c3b53da64cf5760482273a98e575c651a67eec7f77df96b5b642de8f039"

[[package]]
name = "litrs"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "11d3d7f243d5c5a8b9bb5d6dd2b1602c0cb0b9db1621bafc7ed66e35ff9fe092"

[[package]]
name = "lock_api"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "224399e74b87b5f3557511d98dff8b14089b3dadafcab6bb93eab67d3aace965"
dependencies = [
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e5032e24019045c762d3c0f28f5b6b8bbf38563a65908389bf7978758920897"

[[package]]
name = "mach2"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d640282b302c0bb0a2a8e0233ead9035e3bed871f0b7e81fe4a1ec829765db44"
dependencies = [
 "libc",
]

[[package]]
name = "malloc_buf"
version = "0.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62bb907fe88d54d8d9ce32a3cceab4218ed2f6b7d35617cafe9adf84e43919cb"
dependencies = [
 "libc",
]

[[package]]
name = "matchers"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d1525a2a28c7f4fa0fc98bb91ae755d1e2d1505079e05539e35bc876b5d65ae9"
dependencies = [
 "regex-automata",
]

[[package]]
name = "memchr"
version = "2.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f52b00d39961fc5b2736ea853c9cc86238e165017a493d1d5c8eac6bdc4cc273"

[[package]]
name = "memmap2"
version = "0.9.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "744133e4a0e0a658e1374cf3bf8e415c4052a15a111acd372764c55b4177d490"
dependencies = [
 "libc",
]

[[package]]
name = "metal"
version = "0.29.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7ecfd3296f8c56b7c1f6fbac3c71cefa9d78ce009850c45000015f206dc7fa21"
dependencies = [
 "bitflags 2.10.0",
 "block",
 "core-graphics-types",
 "foreign-types",
 "log",
 "objc",
 "paste",
]

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "miniz_oxide"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
dependencies = [
 "adler2",
 "simd-adler32",
]

[[package]]
name = "moxcms"
version = "0.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac9557c559cd6fc9867e122e20d2cbefc9ca29d80d027a8e39310920ed2f0a97"
dependencies = [
 "num-traits",
 "pxfm",
]

[[package]]
name = "naga"
version = "23.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "364f94bc34f61332abebe8cad6f6cd82a5b65cff22c828d05d0968911462ca4f"
dependencies = [
 "arrayvec",
 "bit-set 0.8.0",
 "bitflags 2.10.0",
 "cfg_aliases 0.1.1",
 "codespan-reporting",
 "hexf-parse",
 "indexmap",
 "log",
 "pp-rs",
 "rustc-hash 1.1.0",
 "spirv",
 "termcolor",
 "thiserror",
 "unicode-xid",
]

[[package]]
name = "naga_oil"
version = "0.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "31ea1f080bb359927cd5404d0af1e5e6758f4f2d82ecfbebb0a0c434764e40f1"
dependencies = [
 "bit-set 0.5.3",
 "codespan-reporting",
 "data-encoding",
 "indexmap",
 "naga",
 "once_cell",
 "regex",
 "regex-syntax",
 "rustc-hash 1.1.0",
 "thiserror",
 "tracing",
 "unicode-ident",
]

[[package]]
name = "ndk"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2076a31b7010b17a38c01907c45b945e8f11495ee4dd588309718901b1f7a5b7"
dependencies = [
 "bitflags 2.10.0",
 "jni-sys",
 "log",
 "ndk-sys 0.5.0+25.2.9519653",
 "num_enum",
 "thiserror",
]

[[package]]
name = "ndk"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3f42e7bbe13d351b6bead8286a43aac9534b82bd3cc43e47037f012ebfd62d4"
dependencies = [
 "bitflags 2.10.0",
 "jni-sys",
 "log",
 "ndk-sys 0.6.0+11769913",
 "num_enum",
 "raw-window-handle",
 "thiserror",
]

[[package]]
name = "ndk-context"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "27b02d87554356db9e9a873add8782d4ea6e3e58ea071a9adb9a2e8ddb884a8b"

[[package]]
name = "ndk-sys"
version = "0.5.0+25.2.9519653"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8c196769dd60fd4f363e11d948139556a344e79d451aeb2fa2fd040738ef7691"
dependencies = [
 "jni-sys",
]

[[package]]
name = "ndk-sys"
version = "0.6.0+11769913"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee6cda3051665f1fb8d9e08fc35c96d5a244fb1be711a03b71118828afc9a873"
dependencies = [
 "jni-sys",
]

[[package]]
name = "nix"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74523f3a35e05aba87a1d978330aef40f67b0304ac79c1c00b294c9830543db6"
dependencies = [
 "bitflags 2.10.0",
 "cfg-if",
 "cfg_aliases 0.2.1",
 "libc",
]

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "nonmax"
version = "0.5.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "610a5acd306ec67f907abe5567859a3c693fb9886eb1f012ab8f2a47bef3db51"

[[package]]
name = "ntapi"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c70f219e21142367c70c0b30c6a9e3a14d55b4d12a204d897fbec83a0363f081"
dependencies = [
 "winapi",
]

[[package]]
name = "nu-ansi-term"
version = "0.50.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7957b9740744892f114936ab4a57b3f487491bbeafaf8083688b16841a4240e5"
dependencies = [
 "windows-sys 0.61.2",
]

[[package]]
name = "num-derive"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed3955f1a9c7c0c15e092f9c887db08b1fc683305fdf6eb6684f22555355e202"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
 "libm",
]

[[package]]
name = "num_enum"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b1207a7e20ad57b847bbddc6776b968420d38292bbfe2089accff5e19e82454c"
dependencies = [
 "num_enum_derive",
 "rustversion",
]

[[package]]
name = "num_enum_derive"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff32365de1b6743cb203b710788263c44a03de03802daf96092f2da4fe6ba4d7"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "objc"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "915b1b472bc21c53464d6c8461c9d3af805ba1ef837e1cac254428f4a77177b1"
dependencies = [
 "malloc_buf",
]

[[package]]
name = "objc-sys"
version = "0.3.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cdb91bdd390c7ce1a8607f35f3ca7151b65afc0ff5ff3b34fa350f7d7c7e4310"

[[package]]
name = "objc2"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46a785d4eeff09c14c487497c162e92766fbb3e4059a71840cecc03d9a50b804"
dependencies = [
 "objc-sys",
 "objc2-encode",
]

[[package]]
name = "objc2"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b7c2599ce0ec54857b29ce62166b0ed9b4f6f1a70ccc9a71165b6154caca8c05"
dependencies = [
 "objc2-encode",
]

[[package]]
name = "objc2-app-kit"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e4e89ad9e3d7d297152b17d39ed92cd50ca8063a89a9fa569046d41568891eff"
dependencies = [
 "bitflags 2.10.0",
 "block2 0.5.1",
 "libc",
 "objc2 0.5.2",
 "objc2-core-data",
 "objc2-core-image",
 "objc2-foundation",
 "objc2-quartz-core",
]

[[package]]
name = "objc2-cloud-kit"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74dd3b56391c7a0596a295029734d3c1c5e7e510a4cb30245f8221ccea96b009"
dependencies = [
 "bitflags 2.10.0",
 "block2 0.5.1",
 "objc2 0.5.2",
 "objc2-core-location",
 "objc2-foundation",
]

[[package]]
name = "objc2-contacts"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a5ff520e9c33812fd374d8deecef01d4a840e7b41862d849513de77e44aa4889"
dependencies = [
 "block2 0.5.1",
 "objc2 0.5.2",
 "objc2-foundation",
]

[[package]]
name = "objc2-core-data"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "617fbf49e071c178c0b24c080767db52958f716d9eabdf0890523aeae54773ef"
dependencies = [
 "bitflags 2.10.0",
 "block2 0.5.1",
 "objc2 0.5.2",
 "objc2-foundation",
]

[[package]]
name = "objc2-core-image"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55260963a527c99f1819c4f8e3b47fe04f9650694ef348ffd2227e8196d34c80"
dependencies = [
 "block2 0.5.1",
 "objc2 0.5.2",
 "objc2-foundation",
 "objc2-metal",
]

[[package]]
name = "objc2-core-location"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "000cfee34e683244f284252ee206a27953279d370e309649dc3ee317b37e5781"
dependencies = [
 "block2 0.5.1",
 "objc2 0.5.2",
 "objc2-contacts",
 "objc2-foundation",
]

[[package]]
name = "objc2-encode"
version = "4.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef25abbcd74fb2609453eb695bd2f860d389e457f67dc17cafc8b8cbc89d0c33"

[[package]]
name = "objc2-foundation"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ee638a5da3799329310ad4cfa62fbf045d5f56e3ef5ba4149e7452dcf89d5a8"
dependencies = [
 "bitflags 2.10.0",
 "block2 0.5.1",
 "dispatch",
 "libc",
 "objc2 0.5.2",
]

[[package]]
name = "objc2-link-presentation"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1a1ae721c5e35be65f01a03b6d2ac13a54cb4fa70d8a5da293d7b0020261398"
dependencies = [
 "block2 0.5.1",
 "objc2 0.5.2",
 "objc2-app-kit",
 "objc2-foundation",
]

[[package]]
name = "objc2-metal"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd0cba1276f6023976a406a14ffa85e1fdd19df6b0f737b063b95f6c8c7aadd6"
dependencies = [
 "bitflags 2.10.0",
 "block2 0.5.1",
 "objc2 0.5.2",
 "objc2-foundation",
]

[[package]]
name = "objc2-quartz-core"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e42bee7bff906b14b167da2bac5efe6b6a07e6f7c0a21a7308d40c960242dc7a"
dependencies = [
 "bitflags 2.10.0",
 "block2 0.5.1",
 "objc2 0.5.2",
 "objc2-foundation",
 "objc2-metal",
]

[[package]]
name = "objc2-symbols"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a684efe3dec1b305badae1a28f6555f6ddd3bb2c2267896782858d5a78404dc"
dependencies = [
 "objc2 0.5.2",
 "objc2-foundation",
]

[[package]]
name = "objc2-ui-kit"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8bb46798b20cd6b91cbd113524c490f1686f4c4e8f49502431415f3512e2b6f"
dependencies = [
 "bitflags 2.10.0",
 "block2 0.5.1",
 "objc2 0.5.2",
 "objc2-cloud-kit",
 "objc2-core-data",
 "objc2-core-image",
 "objc2-core-location",
 "objc2-foundation",
 "objc2-link-presentation",
 "objc2-quartz-core",
 "objc2-symbols",
 "objc2-uniform-type-identifiers",
 "objc2-user-notifications",
]

[[package]]
name = "objc2-uniform-type-identifiers"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44fa5f9748dbfe1ca6c0b79ad20725a11eca7c2218bceb4b005cb1be26273bfe"
dependencies = [
 "block2 0.5.1",
 "objc2 0.5.2",
 "objc2-foundation",
]

[[package]]
name = "objc2-user-notifications"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76cfcbf642358e8689af64cee815d139339f3ed8ad05103ed5eaf73db8d84cb3"
dependencies = [
 "bitflags 2.10.0",
 "block2 0.5.1",
 "objc2 0.5.2",
 "objc2-core-location",
 "objc2-foundation",
]

[[package]]
name = "oboe"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8b61bebd49e5d43f5f8cc7ee2891c16e0f41ec7954d36bcb6c14c5e0de867fb"
dependencies = [
 "jni",
 "ndk 0.8.0",
 "ndk-context",
 "num-derive",
 "num-traits",
 "oboe-sys",
]

[[package]]
name = "oboe-sys"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c8bb09a4a2b1d668170cfe0a7d5bc103f8999fb316c98099b6a9939c9f2e79d"
dependencies = [
 "cc",
]

[[package]]
name = "offset-allocator"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e234d535da3521eb95106f40f0b73483d80bfb3aacf27c40d7e2b72f1a3e00a2"
dependencies = [
 "log",
 "nonmax",
]

[[package]]
name = "ogg"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6951b4e8bf21c8193da321bcce9c9dd2e13c858fe078bf9054a288b419ae5d6e"
dependencies = [
 "byteorder",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "orbclient"
version = "0.3.50"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "52ad2c6bae700b7aa5d1cc30c59bdd3a1c180b09dbaea51e2ae2b8e1cf211fdd"
dependencies = [
 "libc",
 "libredox",
]

[[package]]
name = "parking"
version = "2.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f38d5652c16fde515bb1ecef450ab0f6a219d619a7274976324d5e377f7dceba"

[[package]]
name = "parking_lot"
version = "0.12.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93857453250e3077bd71ff98b6a65ea6621a19bb0f559a85248955ac12c45a1a"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2621685985a2ebf1c516881c026032ac7deafcda1a2c9b7850dc81e3dfcb64c1"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall 0.5.18",
 "smallvec",
 "windows-link",
]

[[package]]
name = "paste"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"

[[package]]
name = "percent-encoding"
version = "2.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b4f627cb1b25917193a259e49bdad08f671f8d9708acfd5fe0a8c1455d87220"

[[package]]
name = "petgraph"
version = "0.6.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4c5cc86750666a3ed20bdaf5ca2a0344f9c67674cae0515bec2da16fbaa47db"
dependencies = [
 "fixedbitset 0.4.2",
 "indexmap",
 "serde",
 "serde_derive",
]

[[package]]
name = "pin-project"
version = "1.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677f1add503faace112b9f1373e43e9e054bfdd22ff1a63c1bc485eaec6a6a8a"
dependencies = [
 "pin-project-internal",
]

[[package]]
name = "pin-project-internal"
version = "1.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e918e4ff8c4549eb882f14b3a4bc8c8bc93de829416eacf579f1207a8fbf861"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "piper"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96c8c490f422ef9a4efd2cb5b42b76c8613d7e7dfc1caf667b8a3350a5acc066"
dependencies = [
 "atomic-waker",
 "fastrand",
 "futures-io",
]

[[package]]
name = "pkg-config"
version = "0.3.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"

[[package]]
name = "png"
version = "0.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97baced388464909d42d89643fe4361939af9b7ce7a31ee32a168f832a70f2a0"
dependencies = [
 "bitflags 2.10.0",
 "crc32fast",
 "fdeflate",
 "flate2",
 "miniz_oxide",
]

[[package]]
name = "polling"
version = "3.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d0e4f59085d47d8241c88ead0f274e8a0cb551f3625263c05eb8dd897c34218"
dependencies = [
 "cfg-if",
 "concurrent-queue",
 "hermit-abi",
 "pin-project-lite",
 "rustix 1.1.3",
 "windows-sys 0.61.2",
]

[[package]]
name = "portable-atomic"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f89776e4d69bb58bc6993e99ffa1d11f228b839984854c7daeb5d37f87cbe950"

[[package]]
name = "portable-atomic-util"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8a2f0d8d040d7848a709caf78912debcc3f33ee4b3cac47d73d1e1069e83507"
dependencies = [
 "portable-atomic",
]

[[package]]
name = "pp-rs"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bb458bb7f6e250e6eb79d5026badc10a3ebb8f9a15d1fff0f13d17c71f4d6dee"
dependencies = [
 "unicode-xid",
]

[[package]]
name = "ppv-lite86"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
dependencies = [
 "zerocopy",
]

[[package]]
name = "presser"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8cf8e6a8aa66ce33f63993ffc4ea4271eb5b0530a9002db8455ea6050c77bfa"

[[package]]
name = "prettyplease"
version = "0.2.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "479ca8adacdd7ce8f1fb39ce9ecccbfe93a3f1344b3d0d97f20bc0196208f62b"
dependencies = [
 "proc-macro2",
 "syn",
]

[[package]]
name = "proc-macro-crate"
version = "3.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "219cb19e96be00ab2e37d6e299658a0cfa83e52429179969b0f0121b4ac46983"
dependencies = [
 "toml_edit 0.23.10+spec-1.0.0",
]

[[package]]
name = "proc-macro2"
version = "1.0.104"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9695f8df41bb4f3d222c95a67532365f569318332d03d5f3f67f37b20e6ebdf0"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "profiling"
version = "1.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3eb8486b569e12e2c32ad3e204dbaba5e4b5b216e9367044f25f1dba42341773"

[[package]]
name = "pxfm"
version = "0.1.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7186d3822593aa4393561d186d1393b3923e9d6163d3fbfd6e825e3e6cf3e6a8"
dependencies = [
 "num-traits",
]

[[package]]
name = "quote"
version = "1.0.42"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a338cc41d27e6cc6dce6cefc13a0729dfbb81c262b1f519331575dd80ef3067f"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "radsort"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "019b4b213425016d7d84a153c4c73afb0946fbb4840e4eece7ba8848b9d6da22"

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom 0.2.16",
]

[[package]]
name = "rand_distr"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32cb0b9bc82b0a0876c2dd994a7e7a2683d3e7390ca40e6886785ef0c7e3ee31"
dependencies = [
 "num-traits",
 "rand",
]

[[package]]
name = "range-alloc"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3d6831663a5098ea164f89cff59c6284e95f4e3c76ce9848d4529f5ccca9bde"

[[package]]
name = "rangemap"
version = "1.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "973443cf09a9c8656b574a866ab68dfa19f0867d0340648c7d2f6a71b8a8ea68"

[[package]]
name = "raw-window-handle"
version = "0.6.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "20675572f6f24e9e76ef639bc5552774ed45f1c30e2951e1e99c59888861c539"

[[package]]
name = "rayon"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "368f01d005bf8fd9b1206fb6fa653e6c4a81ceb1466406b81792d87c5677a58f"
dependencies = [
 "either",
 "rayon-core",
]

[[package]]
name = "rayon-core"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22e18b0f0062d30d4230b2e85ff77fdfe4326feb054b9783a3460d8435c8ab91"
dependencies = [
 "crossbeam-deque",
 "crossbeam-utils",
]

[[package]]
name = "read-fonts"
version = "0.22.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69aacb76b5c29acfb7f90155d39759a29496aebb49395830e928a9703d2eec2f"
dependencies = [
 "bytemuck",
 "font-types",
]

[[package]]
name = "rectangle-pack"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a0d463f2884048e7153449a55166f91028d5b0ea53c79377099ce4e8cf0cf9bb"

[[package]]
name = "redox_syscall"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4722d768eff46b75989dd134e5c353f0d6296e5aaa3132e776cbdb56be7731aa"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_syscall"
version = "0.5.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed2bf2547551a7053d6fdfafda3f938979645c44812fbfcda098faae3f1a362d"
dependencies = [
 "bitflags 2.10.0",
]

[[package]]
name = "redox_syscall"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49f3fe0889e69e2ae9e41f4d6c4c0181701d00e4697b356fb1f74173a5e0ee27"
dependencies = [
 "bitflags 2.10.0",
]

[[package]]
name = "regex"
version = "1.12.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "843bc0191f75f3e22651ae5f1e72939ab2f72a4bc30fa80a066bd66edefc24d4"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5276caf25ac86c8d810222b3dbb938e512c55c6831a10f3e6ed1c93b84041f1c"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a2d987857b319362043e95f5353c0535c1f58eec5336fdfcf626430af7def58"

[[package]]
name = "renderdoc-sys"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19b30a45b0cd0bcca8037f3d0dc3421eaf95327a17cad11964fb8179b4fc4832"

[[package]]
name = "rodio"
version = "0.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6006a627c1a38d37f3d3a85c6575418cfe34a5392d60a686d0071e1c8d427acb"
dependencies = [
 "cpal",
 "lewton",
 "thiserror",
]

[[package]]
name = "ron"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b91f7eff05f748767f183df4320a63d6936e9c6107d97c9e6bdd9784f4289c94"
dependencies = [
 "base64 0.21.7",
 "bitflags 2.10.0",
 "serde",
 "serde_derive",
]

[[package]]
name = "ron"
version = "0.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd490c5b18261893f14449cbd28cb9c0b637aebf161cd77900bfdedaff21ec32"
dependencies = [
 "bitflags 2.10.0",
 "once_cell",
 "serde",
 "serde_derive",
 "typeid",
 "unicode-ident",
]

[[package]]
name = "roxmltree"
version = "0.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c20b6793b5c2fa6553b250154b78d6d0db37e72700ae35fad9387a46f487c97"

[[package]]
name = "rustc-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"

[[package]]
name = "rustc-hash"
version = "2.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "357703d41365b4b27c590e3ed91eabb1b663f07c4c084095e60cbed4362dff0d"

[[package]]
name = "rustix"
version = "0.38.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fdb5bc1ae2baa591800df16c9ca78619bf65c0488b41b96ccec5d11220d8c154"
dependencies = [
 "bitflags 2.10.0",
 "errno",
 "libc",
 "linux-raw-sys 0.4.15",
 "windows-sys 0.59.0",
]

[[package]]
name = "rustix"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "146c9e247ccc180c1f61615433868c99f3de3ae256a30a43b49f67c2d9171f34"
dependencies = [
 "bitflags 2.10.0",
 "errno",
 "libc",
 "linux-raw-sys 0.11.0",
 "windows-sys 0.61.2",
]

[[package]]
name = "rustversion"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"

[[package]]
name = "rustybuzz"
version = "0.14.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfb9cf8877777222e4a3bc7eb247e398b56baba500c38c1c46842431adc8b55c"
dependencies = [
 "bitflags 2.10.0",
 "bytemuck",
 "libm",
 "smallvec",
 "ttf-parser 0.21.1",
 "unicode-bidi-mirroring",
 "unicode-ccc",
 "unicode-properties",
 "unicode-script",
]

[[package]]
name = "ruzstd"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fad02996bfc73da3e301efe90b1837be9ed8f4a462b6ed410aa35d00381de89f"
dependencies = [
 "twox-hash",
]

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "self_cell"
version = "1.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b12e76d157a900eb52e81bc6e9f3069344290341720e9178cde2407113ac8d89"

[[package]]
name = "send_wrapper"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd0b0ec5f1c1ca621c432a25813d8d60c88abe6d3e08a3eb9cf37d97a0fe3d73"

[[package]]
name = "serde"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a8e94ea7f378bd32cbbd37198a4a91436180c5bb472411e48b5ec2e2124ae9e"
dependencies = [
 "serde_core",
 "serde_derive",
]

[[package]]
name = "serde_core"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41d385c7d4ca58e59fc732af25c3983b67ac852c1a25000afe1175de458b67ad"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d540f220d3187173da220f885ab66608367b6574e925011a9353e4badda91d79"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.148"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3084b546a1dd6289475996f182a22aba973866ea8e8b02c51d9f46b1336a22da"
dependencies = [
 "itoa",
 "memchr",
 "serde",
 "serde_core",
 "zmij",
]

[[package]]
name = "sharded-slab"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
dependencies = [
 "lazy_static",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "simd-adler32"
version = "0.3.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e320a6c5ad31d271ad523dcf3ad13e2767ad8b1cb8f047f75a8aeaf8da139da2"

[[package]]
name = "skrifa"
version = "0.22.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e1c44ad1f6c5bdd4eefed8326711b7dbda9ea45dfd36068c427d332aa382cbe"
dependencies = [
 "bytemuck",
 "read-fonts",
]

[[package]]
name = "slab"
version = "0.4.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a2ae44ef20feb57a68b23d846850f861394c2e02dc425a50098ae8c90267589"

[[package]]
name = "slotmap"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bdd58c3c93c3d278ca835519292445cb4b0d4dc59ccfdf7ceadaab3f8aeb4038"
dependencies = [
 "version_check",
]

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"

[[package]]
name = "smol_str"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd538fb6910ac1099850255cf94a94df6551fbdd602454387d0adb2d1ca6dead"
dependencies = [
 "serde",
]

[[package]]
name = "spirv"
version = "0.3.0+sdk-1.3.268.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eda41003dc44290527a59b13432d4a0379379fa074b70174882adfbdfd917844"
dependencies = [
 "bitflags 2.10.0",
]

[[package]]
name = "stackfuture"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "115beb9c69db2393ff10b75a1b8587a51716e5551d015001e55320ed279d32f9"
dependencies = [
 "const_panic",
]

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "svg_fmt"
version = "0.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0193cc4331cfd2f3d2011ef287590868599a2f33c3e69bc22c1a3d3acf9e02fb"

[[package]]
name = "swash"
version = "0.1.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cbd59f3f359ddd2c95af4758c18270eddd9c730dde98598023cdabff472c2ca2"
dependencies = [
 "skrifa",
 "yazi",
 "zeno",
]

[[package]]
name = "syn"
version = "2.0.112"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "21f182278bf2d2bcb3c88b1b08a37df029d71ce3d3ae26168e3c653b213b99d4"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "sys-locale"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8eab9a99a024a169fe8a903cf9d4a3b3601109bcc13bd9e3c6fff259138626c4"
dependencies = [
 "libc",
]

[[package]]
name = "sysinfo"
version = "0.32.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c33cd241af0f2e9e3b5c32163b873b29956890b5342e6745b917ce9d490f4af"
dependencies = [
 "core-foundation-sys",
 "libc",
 "memchr",
 "ntapi",
 "windows 0.57.0",
]

[[package]]
name = "taffy"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9cb893bff0f80ae17d3a57e030622a967b8dbc90e38284d9b4b1442e23873c94"
dependencies = [
 "arrayvec",
 "grid",
 "num-traits",
 "serde",
 "slotmap",
]

[[package]]
name = "termcolor"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
dependencies = [
 "winapi-util",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thread_local"
version = "1.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f60246a4944f24f6e018aa17cdeffb7818b76356965d03b07d6a9886e8962185"
dependencies = [
 "cfg-if",
]

[[package]]
name = "tiny-keccak"
version = "2.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c9d3793400a45f954c52e73d068316d76b6f4e36977e3fcebb13a2721e80237"
dependencies = [
 "crunchy",
]

[[package]]
name = "tinyvec"
version = "1.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa5fdc3bce6191a1dbc8c02d5c8bffcf557bafa17c124c5264a458f1b0613fa"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "toml_datetime"
version = "0.6.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22cddaf88f4fbc13c51aebbf5f8eceb5c7c5a9da2ac40a13519eb5b0a0e8f11c"

[[package]]
name = "toml_datetime"
version = "0.7.5+spec-1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "92e1cfed4a3038bc5a127e35a2d360f145e1f4b971b551a2ba5fd7aedf7e1347"
dependencies = [
 "serde_core",
]

[[package]]
name = "toml_edit"
version = "0.22.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41fe8c660ae4257887cf66394862d21dbca4a6ddd26f04a3560410406a2f819a"
dependencies = [
 "indexmap",
 "toml_datetime 0.6.11",
 "winnow",
]

[[package]]
name = "toml_edit"
version = "0.23.10+spec-1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "84c8b9f757e028cee9fa244aea147aab2a9ec09d5325a9b01e0a49730c2b5269"
dependencies = [
 "indexmap",
 "toml_datetime 0.7.5+spec-1.1.0",
 "toml_parser",
 "winnow",
]

[[package]]
name = "toml_parser"
version = "1.0.6+spec-1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a3198b4b0a8e11f09dd03e133c0280504d0801269e9afa46362ffde1cbeebf44"
dependencies = [
 "winnow",
]

[[package]]
name = "tracing"
version = "0.1.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "63e71662fa4b2a2c3a26f570f037eb95bb1f85397f3cd8076caed2f026a6d100"
dependencies = [
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7490cfa5ec963746568740651ac6781f701c9c5ea257c58e057f3ba8cf69e8da"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tracing-core"
version = "0.1.36"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db97caf9d906fbde555dd62fa95ddba9eecfd14cb388e4f491a66d74cd5fb79a"
dependencies = [
 "once_cell",
 "valuable",
]

[[package]]
name = "tracing-log"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-oslog"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "528bdd1f0e27b5dd9a4ededf154e824b0532731e4af73bb531de46276e0aab1e"
dependencies = [
 "bindgen 0.70.1",
 "cc",
 "cfg-if",
 "once_cell",
 "parking_lot",
 "tracing-core",
 "tracing-subscriber",
]

[[package]]
name = "tracing-subscriber"
version = "0.3.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f30143827ddab0d256fd843b7a66d164e9f271cfa0dde49142c5ca0ca291f1e"
dependencies = [
 "matchers",
 "nu-ansi-term",
 "once_cell",
 "regex-automata",
 "sharded-slab",
 "smallvec",
 "thread_local",
 "tracing",
 "tracing-core",
 "tracing-log",
]

[[package]]
name = "tracing-wasm"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4575c663a174420fa2d78f4108ff68f65bf2fbb7dd89f33749b6e826b3626e07"
dependencies = [
 "tracing",
 "tracing-subscriber",
 "wasm-bindgen",
]

[[package]]
name = "ttf-parser"
version = "0.20.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17f77d76d837a7830fe1d4f12b7b4ba4192c1888001c7164257e4bc6d21d96b4"

[[package]]
name = "ttf-parser"
version = "0.21.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c591d83f69777866b9126b24c6dd9a18351f177e49d625920d19f989fd31cf8"

[[package]]
name = "twox-hash"
version = "1.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97fee6b57c6a41524a810daee9286c02d7752c4253064d0b05472833a438f675"
dependencies = [
 "cfg-if",
 "static_assertions",
]

[[package]]
name = "typeid"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc7d623258602320d5c55d1bc22793b57daff0ec7efc270ea7d55ce1d5f5471c"

[[package]]
name = "typewit"
version = "1.14.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8c1ae7cc0fdb8b842d65d127cb981574b0d2b249b74d1c7a2986863dc134f71"

[[package]]
name = "unicode-bidi"
version = "0.3.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c1cb5db39152898a79168971543b1cb5020dff7fe43c8dc468b0885f5e29df5"

[[package]]
name = "unicode-bidi-mirroring"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23cb788ffebc92c5948d0e997106233eeb1d8b9512f93f41651f52b6c5f5af86"

[[package]]
name = "unicode-ccc"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1df77b101bcc4ea3d78dafc5ad7e4f58ceffe0b2b16bf446aeb50b6cb4157656"

[[package]]
name = "unicode-ident"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9312f7c4f6ff9069b165498234ce8be658059c6728633667c526e27dc2cf1df5"

[[package]]
name = "unicode-linebreak"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b09c83c3c29d37506a3e260c08c03743a6bb66a9cd432c6934ab501a190571f"

[[package]]
name = "unicode-properties"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7df058c713841ad818f1dc5d3fd88063241cc61f49f5fbea4b951e8cf5a8d71d"

[[package]]
name = "unicode-script"
version = "0.5.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "383ad40bb927465ec0ce7720e033cb4ca06912855fc35db31b5755d0de75b1ee"

[[package]]
name = "unicode-segmentation"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6ccf251212114b54433ec949fd6a7841275f9ada20dddd2f29e9ceea4501493"

[[package]]
name = "unicode-width"
version = "0.1.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7dd6e30e90baa6f72411720665d41d89b9a3d039dc45b8faea1ddd07f617f6af"

[[package]]
name = "unicode-xid"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebc1c04c71510c7f702b52b7c350734c9ff1295c464a03335b00bb84fc54f853"

[[package]]
name = "uuid"
version = "1.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b3758f5e68192bb96cc8f9b7e2c2cfdabb435499a28499a42f8f984092adad4b"
dependencies = [
 "getrandom 0.2.16",
 "serde",
]

[[package]]
name = "valuable"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba73ea9cf16a25df0c8caa16c51acb937d5712a8429db78a3ee29d5dcacd3a65"

[[package]]
name = "vec_map"
version = "0.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1bddf1187be692e79c5ffeab891132dfb0f236ed36a43c7ed39f1165ee20191"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "walkdir"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasip2"
version = "1.0.1+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0562428422c63773dad2c345a1882263bbf4d65cf3f42e90921f787ef5ad58e7"
dependencies = [
 "wit-bindgen",
]

[[package]]
name = "wasm-bindgen"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d759f433fa64a2d763d1340820e46e111a7a5ab75f993d1852d70b03dbb80fd"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.56"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "836d9622d604feee9e5de25ac10e3ea5f2d65b41eac0d9ce72eb5deae707ce7c"
dependencies = [
 "cfg-if",
 "js-sys",
 "once_cell",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48cb0d2638f8baedbc542ed444afc0644a29166f1595371af4fecf8ce1e7eeb3"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cefb59d5cd5f92d9dcf80e4683949f15ca4b511f4ac0a6e14d4e1ac60c6ecd40"
dependencies = [
 "bumpalo",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cbc538057e648b67f72a982e708d485b2efa771e1ac05fec311f9f63e5800db4"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "web-sys"
version = "0.3.83"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b32828d774c412041098d182a8b38b16ea816958e07cf40eec2bc080ae137ac"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "web-time"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a6580f308b1fad9207618087a65c04e7a10bc77e02c8e84e9b00dd4b12fa0bb"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "wgpu"
version = "23.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80f70000db37c469ea9d67defdc13024ddf9a5f1b89cb2941b812ad7cde1735a"
dependencies = [
 "arrayvec",
 "cfg_aliases 0.1.1",
 "document-features",
 "js-sys",
 "log",
 "naga",
 "parking_lot",
 "profiling",
 "raw-window-handle",
 "smallvec",
 "static_assertions",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "wgpu-core",
 "wgpu-hal",
 "wgpu-types",
]

[[package]]
name = "wgpu-core"
version = "23.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d63c3c478de8e7e01786479919c8769f62a22eec16788d8c2ac77ce2c132778a"
dependencies = [
 "arrayvec",
 "bit-vec 0.8.0",
 "bitflags 2.10.0",
 "cfg_aliases 0.1.1",
 "document-features",
 "indexmap",
 "log",
 "naga",
 "once_cell",
 "parking_lot",
 "profiling",
 "raw-window-handle",
 "rustc-hash 1.1.0",
 "smallvec",
 "thiserror",
 "wgpu-hal",
 "wgpu-types",
]

[[package]]
name = "wgpu-hal"
version = "23.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89364b8a0b211adc7b16aeaf1bd5ad4a919c1154b44c9ce27838213ba05fd821"
dependencies = [
 "android_system_properties",
 "arrayvec",
 "ash",
 "bit-set 0.8.0",
 "bitflags 2.10.0",
 "block",
 "bytemuck",
 "cfg_aliases 0.1.1",
 "core-graphics-types",
 "glow",
 "glutin_wgl_sys",
 "gpu-alloc",
 "gpu-allocator",
 "gpu-descriptor",
 "js-sys",
 "khronos-egl",
 "libc",
 "libloading",
 "log",
 "metal",
 "naga",
 "ndk-sys 0.5.0+25.2.9519653",
 "objc",
 "once_cell",
 "parking_lot",
 "profiling",
 "range-alloc",
 "raw-window-handle",
 "renderdoc-sys",
 "rustc-hash 1.1.0",
 "smallvec",
 "thiserror",
 "wasm-bindgen",
 "web-sys",
 "wgpu-types",
 "windows 0.58.0",
 "windows-core 0.58.0",
]

[[package]]
name = "wgpu-types"
version = "23.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "610f6ff27778148c31093f3b03abc4840f9636d58d597ca2f5977433acfe0068"
dependencies = [
 "bitflags 2.10.0",
 "js-sys",
 "web-sys",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2a7b1c03c876122aa43f3020e6c3c3ee5c05081c9a00739faf7503aeba10d22"
dependencies = [
 "windows-sys 0.61.2",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows"
version = "0.54.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9252e5725dbed82865af151df558e754e4a3c2c30818359eb17465f1346a1b49"
dependencies = [
 "windows-core 0.54.0",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows"
version = "0.57.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "12342cb4d8e3b046f3d80effd474a7a02447231330ef77d71daa6fbc40681143"
dependencies = [
 "windows-core 0.57.0",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd04d41d93c4992d421894c18c8b43496aa748dd4c081bac0dc93eb0489272b6"
dependencies = [
 "windows-core 0.58.0",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-core"
version = "0.54.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "12661b9c89351d684a50a8a643ce5f608e20243b9fb84687800163429f161d65"
dependencies = [
 "windows-result 0.1.2",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-core"
version = "0.57.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2ed2439a290666cd67ecce2b0ffaad89c2a56b976b736e6ece670297897832d"
dependencies = [
 "windows-implement 0.57.0",
 "windows-interface 0.57.0",
 "windows-result 0.1.2",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-core"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6ba6d44ec8c2591c134257ce647b7ea6b20335bf6379a27dac5f1641fcf59f99"
dependencies = [
 "windows-implement 0.58.0",
 "windows-interface 0.58.0",
 "windows-result 0.2.0",
 "windows-strings",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-implement"
version = "0.57.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9107ddc059d5b6fbfbffdfa7a7fe3e22a226def0b2608f72e9d552763d3e1ad7"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-implement"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2bbd5b46c938e506ecbce286b6628a02171d56153ba733b6c741fc627ec9579b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-interface"
version = "0.57.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29bee4b38ea3cde66011baa44dba677c432a78593e202392d1e9070cf2a7fca7"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-interface"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "053c4c462dc91d3b1504c6fe5a726dd15e216ba718e84a0e46a88fbe5ded3515"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-link"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0805222e57f7521d6a62e36fa9163bc891acd422f971defe97d64e70d0a4fe5"

[[package]]
name = "windows-result"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e383302e8ec8515204254685643de10811af0ed97ea37210dc26fb0032647f8"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-result"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d1043d8214f791817bab27572aaa8af63732e11bf84aa21a45a78d6c317ae0e"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-strings"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4cd9b125c486025df0eabcb585e62173c6c9eddcec5d117d3b6e8c30e2ee4d10"
dependencies = [
 "windows-result 0.2.0",
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.45.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0"
dependencies = [
 "windows-targets 0.42.2",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae137229bcbd6cdf0f7b80a31df61766145077ddf49416a728b02cb3921ff3fc"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-targets"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071"
dependencies = [
 "windows_aarch64_gnullvm 0.42.2",
 "windows_aarch64_msvc 0.42.2",
 "windows_i686_gnu 0.42.2",
 "windows_i686_msvc 0.42.2",
 "windows_x86_64_gnu 0.42.2",
 "windows_x86_64_gnullvm 0.42.2",
 "windows_x86_64_msvc 0.42.2",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm 0.52.6",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm 0.52.6",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.42.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "winit"
version = "0.30.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c66d4b9ed69c4009f6321f762d6e61ad8a2389cd431b97cb1e146812e9e6c732"
dependencies = [
 "android-activity",
 "atomic-waker",
 "bitflags 2.10.0",
 "block2 0.5.1",
 "bytemuck",
 "calloop",
 "cfg_aliases 0.2.1",
 "concurrent-queue",
 "core-foundation 0.9.4",
 "core-graphics",
 "cursor-icon",
 "dpi",
 "js-sys",
 "libc",
 "ndk 0.9.0",
 "objc2 0.5.2",
 "objc2-app-kit",
 "objc2-foundation",
 "objc2-ui-kit",
 "orbclient",
 "percent-encoding",
 "pin-project",
 "raw-window-handle",
 "redox_syscall 0.4.1",
 "rustix 0.38.44",
 "smol_str",
 "tracing",
 "unicode-segmentation",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "web-time",
 "windows-sys 0.52.0",
 "x11-dl",
 "x11rb",
 "xkbcommon-dl",
]

[[package]]
name = "winnow"
version = "0.7.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5364e9d77fcdeeaa6062ced926ee3381faa2ee02d3eb83a5c27a8825540829"
dependencies = [
 "memchr",
]

[[package]]
name = "wit-bindgen"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f17a85883d4e6d00e8a97c586de764dabcc06133f7f1d55dce5cdc070ad7fe59"

[[package]]
name = "x11-dl"
version = "2.21.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38735924fedd5314a6e548792904ed8c6de6636285cb9fec04d5b1db85c1516f"
dependencies = [
 "libc",
 "once_cell",
 "pkg-config",
]

[[package]]
name = "x11rb"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9993aa5be5a26815fe2c3eacfc1fde061fc1a1f094bf1ad2a18bf9c495dd7414"
dependencies = [
 "as-raw-xcb-connection",
 "gethostname",
 "libc",
 "libloading",
 "once_cell",
 "rustix 1.1.3",
 "x11rb-protocol",
]

[[package]]
name = "x11rb-protocol"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea6fc2961e4ef194dcbfe56bb845534d0dc8098940c7e5c012a258bfec6701bd"

[[package]]
name = "xkbcommon-dl"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d039de8032a9a8856a6be89cea3e5d12fdd82306ab7c94d74e6deab2460651c5"
dependencies = [
 "bitflags 2.10.0",
 "dlib",
 "log",
 "once_cell",
 "xkeysym",
]

[[package]]
name = "xkeysym"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9cc00251562a284751c9973bace760d86c0276c471b4be569fe6b068ee97a56"

[[package]]
name = "xml-rs"
version = "0.8.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3ae8337f8a065cfc972643663ea4279e04e7256de865aa66fe25cec5fb912d3f"

[[package]]
name = "yazi"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c94451ac9513335b5e23d7a8a2b61a7102398b8cca5160829d313e84c9d98be1"

[[package]]
name = "zeno"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd15f8e0dbb966fd9245e7498c7e9e5055d9e5c8b676b95bd67091cd11a1e697"

[[package]]
name = "zerocopy"
version = "0.8.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd74ec98b9250adb3ca554bdde269adf631549f51d8a8f8f0a10b50f1cb298c3"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.8.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8a8d209fdf45cf5138cbb5a506f6b52522a25afccc534d1475dad8e31105c6a"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "zmij"
version = "1.0.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "317f17ff091ac4515f17cc7a190d2769a8c9a96d227de5d64b500b01cda8f2cd"


==================================================
ФАЙЛ: Cargo.toml
==================================================

[package]
name = "cursed_warden"
version = "0.1.0"
edition = "2021"

[dependencies]
bevy = { version = "0.15", features = ["dynamic_linking"] }
rand = "0.8"
ron = "0.12.0"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0.148"

# Enable high optimizations for dependencies (incl. Bevy), but not for our code:
[profile.dev.package."*"]
opt-level = 3

[profile.dev]
opt-level = 1

[profile.release]
lto = true
codegen-units = 1


==================================================
ФАЙЛ: test_output.log
==================================================

   Compiling bevy_render v0.15.3
   Compiling slotmap v1.1.1
   Compiling alsa-sys v0.3.1
   Compiling sharded-slab v0.1.7
error: failed to run custom build command for `alsa-sys v0.3.1`

Caused by:
  process didn't exit successfully: `/app/target/debug/build/alsa-sys-a6a15927edc9aab0/build-script-build` (exit status: 101)
  --- stdout
  cargo:rerun-if-env-changed=ALSA_NO_PKG_CONFIG
  cargo:rerun-if-env-changed=PKG_CONFIG_x86_64-unknown-linux-gnu
  cargo:rerun-if-env-changed=PKG_CONFIG_x86_64_unknown_linux_gnu
  cargo:rerun-if-env-changed=HOST_PKG_CONFIG
  cargo:rerun-if-env-changed=PKG_CONFIG
  cargo:rerun-if-env-changed=ALSA_STATIC
  cargo:rerun-if-env-changed=ALSA_DYNAMIC
  cargo:rerun-if-env-changed=PKG_CONFIG_ALL_STATIC
  cargo:rerun-if-env-changed=PKG_CONFIG_ALL_DYNAMIC
  cargo:rerun-if-env-changed=PKG_CONFIG_PATH_x86_64-unknown-linux-gnu
  cargo:rerun-if-env-changed=PKG_CONFIG_PATH_x86_64_unknown_linux_gnu
  cargo:rerun-if-env-changed=HOST_PKG_CONFIG_PATH
  cargo:rerun-if-env-changed=PKG_CONFIG_PATH
  cargo:rerun-if-env-changed=PKG_CONFIG_LIBDIR_x86_64-unknown-linux-gnu
  cargo:rerun-if-env-changed=PKG_CONFIG_LIBDIR_x86_64_unknown_linux_gnu
  cargo:rerun-if-env-changed=HOST_PKG_CONFIG_LIBDIR
  cargo:rerun-if-env-changed=PKG_CONFIG_LIBDIR
  cargo:rerun-if-env-changed=PKG_CONFIG_SYSROOT_DIR_x86_64-unknown-linux-gnu
  cargo:rerun-if-env-changed=PKG_CONFIG_SYSROOT_DIR_x86_64_unknown_linux_gnu
  cargo:rerun-if-env-changed=HOST_PKG_CONFIG_SYSROOT_DIR
  cargo:rerun-if-env-changed=PKG_CONFIG_SYSROOT_DIR

  --- stderr

  thread 'main' (6692) panicked at /home/jules/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/alsa-sys-0.3.1/build.rs:13:18:

  pkg-config exited with status code 1
  > PKG_CONFIG_ALLOW_SYSTEM_LIBS=1 PKG_CONFIG_ALLOW_SYSTEM_CFLAGS=1 pkg-config --libs --cflags alsa

  The system library `alsa` required by crate `alsa-sys` was not found.
  The file `alsa.pc` needs to be installed and the PKG_CONFIG_PATH environment variable must contain its parent directory.
  The PKG_CONFIG_PATH environment variable is not set.

  HINT: if you have installed the library, try setting PKG_CONFIG_PATH to the directory containing `alsa.pc`.

  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
warning: build failed, waiting for other jobs to finish...


==================================================
ФАЙЛ: test_output_2.log
==================================================

    Blocking waiting for file lock on build directory
   Compiling bevy_core_pipeline v0.15.3
   Compiling alsa-sys v0.3.1
   Compiling matchers v0.2.0
   Compiling x11-dl v2.21.0
   Compiling libudev-sys v0.1.4
   Compiling euclid v0.22.11
   Compiling tracing-log v0.2.0
   Compiling nu-ansi-term v0.50.3
   Compiling serde_json v1.0.148
   Compiling linux-raw-sys v0.4.15
   Compiling roxmltree v0.20.0
   Compiling svg_fmt v0.4.5
   Compiling rustix v0.38.44
   Compiling fontconfig-parser v0.5.8
   Compiling guillotiere v0.6.2
   Compiling tracing-subscriber v0.3.22
   Compiling zmij v1.0.8
   Compiling skrifa v0.22.3
   Compiling rayon-core v1.13.0
   Compiling polling v3.11.0
   Compiling gethostname v1.1.0
   Compiling bevy_picking v0.15.3
   Compiling dlib v0.5.2
   Compiling winit v0.30.12
   Compiling inotify-sys v0.1.5
   Compiling memmap2 v0.9.9
   Compiling cpal v0.15.3
   Compiling unicode-ccc v0.2.0
   Compiling rectangle-pack v0.4.2
   Compiling unicode-properties v0.1.4
   Compiling unicode-script v0.5.8
   Compiling itoa v1.0.17
   Compiling zeno v0.2.3
   Compiling x11rb-protocol v0.13.2
   Compiling inflections v1.1.1
   Compiling percent-encoding v2.3.2
   Compiling as-raw-xcb-connection v1.0.1
   Compiling ttf-parser v0.20.0
   Compiling xkeysym v0.2.1
   Compiling yazi v0.1.6
   Compiling unicode-bidi-mirroring v0.2.0
   Compiling ttf-parser v0.21.1
   Compiling rustybuzz v0.14.1
   Compiling swash v0.1.19
   Compiling xkbcommon-dl v0.4.2
   Compiling x11rb v0.13.2
   Compiling fontdb v0.16.2
   Compiling gltf-derive v1.4.1
   Compiling bevy_sprite v0.15.3
   Compiling inotify v0.11.0
   Compiling calloop v0.13.0
   Compiling rayon v1.11.0
   Compiling bevy_log v0.15.3
   Compiling alsa v0.9.1
   Compiling ogg v0.8.0
   Compiling dasp_sample v0.11.0
   Compiling self_cell v1.2.2
   Compiling unicode-segmentation v1.12.0
   Compiling sys-locale v0.3.2
   Compiling cursor-icon v1.2.0
   Compiling dpi v0.1.2
   Compiling unicode-linebreak v0.1.5
   Compiling unicode-bidi v0.3.18
   Compiling rangemap v1.7.1
   Compiling vec_map v0.8.2
   Compiling gilrs v0.11.0
   Compiling gilrs-core v0.6.6
   Compiling cosmic-text v0.12.1
   Compiling lewton v0.10.2
   Compiling gltf-json v1.4.1
   Compiling bevy_pbr v0.15.3
   Compiling fnv v1.0.7
   Compiling grid v0.14.0
   Compiling taffy v0.5.2
   Compiling gltf v1.4.1
   Compiling rodio v0.19.0
   Compiling accesskit_winit v0.23.1
   Compiling bevy_text v0.15.3
   Compiling bevy_animation v0.15.3
   Compiling bevy_scene v0.15.3
   Compiling approx v0.5.1
   Compiling bevy_gizmos_macros v0.15.3
   Compiling bevy_state_macros v0.15.3
   Compiling base64 v0.22.1
   Compiling bevy_gltf v0.15.3
   Compiling bevy_state v0.15.3
   Compiling bevy_gizmos v0.15.3
   Compiling bevy_winit v0.15.3
   Compiling bevy_ui v0.15.3
   Compiling bevy_audio v0.15.3
   Compiling bevy_gilrs v0.15.3
   Compiling bevy_internal v0.15.3
   Compiling ron v0.12.0
   Compiling bevy_dylib v0.15.3
   Compiling bevy v0.15.3
   Compiling cursed_warden v0.1.0 (/app)
warning: unused variable: `modifier`
   --> src/plugins/combat.rs:176:13
    |
176 |         let modifier = 1.0;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_modifier`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `damage`
   --> src/plugins/combat.rs:191:13
    |
191 |         let damage = 10.0;
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_damage`

warning: unused variable: `modifier`
   --> src/plugins/combat.rs:192:13
    |
192 |         let modifier = 0.5; // Artificial modifier for easy math
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_modifier`

warning: unused variable: `defense`
   --> src/plugins/combat.rs:193:13
    |
193 |         let defense = 20.0;
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_defense`

warning: `cursed_warden` (lib test) generated 4 warnings
warning: unused import: `GameState`
 --> tests/verification.rs:6:48
  |
6 | use cursed_warden::plugins::core::{CorePlugin, GameState};
  |                                                ^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: `cursed_warden` (test "verification") generated 1 warning (run `cargo fix --test "verification"` to apply 1 suggestion)
    Finished `test` profile [optimized + debuginfo] target(s) in 8m 01s
     Running unittests src/lib.rs (target/debug/deps/cursed_warden-463f01092bf9613f)

running 4 tests
test plugins::combat::tests::test_damage_formula_low_pierce ... ok
test plugins::combat::tests::test_material_efficiency ... ok
test plugins::combat::tests::test_damage_formula_high_pierce ... ok
test plugins::combat::tests::test_action_meter_tick ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/main.rs (target/debug/deps/cursed_warden-e3ca9b9058ada26a)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/verification.rs (target/debug/deps/verification-d23b74b18b6e387f)

running 3 tests
test test_inventory_placement_logic ... ok
test test_save_data_creation ... ok
test test_combat_simulation_loop ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests cursed_warden

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


==================================================
ФАЙЛ: docs\Исправление механики инвентаря в стиле Backpack Battles (1).txt
==================================================

﻿Архитектурная реконструкция и техническая спецификация системы инвентаря Cursed Warden: Глубокий анализ, рефакторинг и реализация механик Backpack Battles
1. Исполнительное резюме и постановка архитектурной задачи
Проект "Cursed Warden" представляет собой амбициозную попытку синтеза жанров Narrative Roguelite и Auto-Battler в экосистеме Rust/Bevy. Однако текущее состояние кодовой базы демонстрирует критический архитектурный диссонанс между требованиями жанра "Inventory Tetris" и реализацией Entity Component System (ECS). Пользовательский запрос выявил системные сбои в механике взаимодействия: некорректная обработка событий Drag-and-Drop, ошибки в наложении слоев рендеринга (Z-fighting), отсутствие "кармана" (Limbo/Storage) для временного хранения предметов и фундаментальная неспособность контейнеров (сумок) корректно транспортировать свое содержимое.
Данный отчет представляет собой исчерпывающую техническую спецификацию и план полной реконструкции подсистемы инвентаря. Наша цель — не просто исправить баги, а внедрить робастную, масштабируемую архитектуру Spatial Slot Provider (Пространственный Поставщик Слотов). Этот подход, являющийся индустриальным стандартом для игр уровня Backpack Battles и Diablo, позволяет отделить визуальное представление (UI Nodes) от логического состояния (Grid Topology), обеспечивая детерминированную обработку коллизий и сложную кинематику вложенных сущностей.
В нижеследующих разделах мы проведем деконструкцию механик референса, математическое обоснование новой сеточной модели и предоставим полный исходный код для замены дефектных модулей, адаптированный под новейшие возможности Bevy 0.15 (Observers, Required Components, Picking).
________________
2. Теоретический базис: Топология инвентарного пространства в ECS
2.1. Кризис "Списочного" Менталитета в Grid-Based Системах
Традиционная разработка RPG часто опирается на представление инвентаря как абстрактного списка (Vec<Item>), где позиция предмета является лишь индексом. Однако для жанра Inventory Auto-Battler такой подход фатален. В Backpack Battles инвентарь — это не контейнер данных, а физическое игровое пространство, топологическое поле боя.1
Текущие проблемы пользователя ("предметы не двигаются вместе с сумкой", "новые сумки рисуются поверх предметов") указывают на то, что проект пытается использовать иерархию родитель-потомок (Parent-Child) движка Bevy для логической привязки. В Bevy UI иерархия предназначена для распространения трансформаций (Transform Propagation) и раскладки (Flexbox/Grid Layout), но она не подходит для логики "Тетриса" по двум причинам:
1. Множественное владение: В Backpack Battles один предмет (например, двуручный меч) может лежать одновременно на двух разных сумках (например, "Fanny Pack" и "Leather Bag").3 В ECS сущность может иметь только одного родителя. Следовательно, физическое вложение Entity предмета в Entity сумки архитектурно невозможно для сложных форм.
2. Динамическая перестройка: При перетаскивании сумки предметы внутри неё должны сохранять относительные координаты, но при этом они продолжают занимать глобальные слоты сетки.
2.2. Паттерн "Slot Provider" (Поставщик Слотов)
Для решения задачи мы внедряем архитектуру, где сетка инвентаря виртуальна. Она не существует как единый объект, а проецируется сущностями-сумками.
* Global Grid Space (Глобальное Пространство): Дискретная координатная плоскость $\mathbb{Z}^2$, где каждая точка $(x, y)$ может находиться в одном из трех состояний: Void (пустота, нельзя класть), Slot (активная ячейка сумки), Occupied (занята предметом).
* Bag Entity (Сумка): Сущность, которая излучает валидные слоты в глобальное пространство. Например, сумка размером 2x2 в координатах $(5, 5)$ делает валидными ячейки $\{(5,5), (5,6), (6,5), (6,6)\}$.
* Item Entity (Предмет): Сущность, которая потребляет валидные слоты. Для успешного размещения предмета необходимо, чтобы все ячейки, покрываемые его формой (Shape Matrix), находились в состоянии Slot и не были Occupied.4
2.3. Математика вращения и дискретной геометрии
Реализация механики вращения (поворот на 90 градусов) требует применения матричных преобразований в дискретном пространстве. Если форма предмета задана набором векторов-смещений $S = \{ \vec{v}_1, \dots, \vec{v}_n \}$ относительно опорной точки (Anchor Point, $(0,0)$), то поворот на 90 градусов по часовой стрелке описывается матрицей поворота:




$$R_{90} = \begin{pmatrix} 0 & -1 \\ 1 & 0 \end{pmatrix}$$


Для каждой точки $(x, y)$ формы преобразование будет: $x' = -y, y' = x$. Однако в экранных координатах (где $Y$ растет вниз) это часто требует коррекции смещения (Pivot Offset), чтобы предмет визуально вращался вокруг курсора, а не улетал вдаль. В представленном коде мы реализуем алгоритм rotate_shape, который корректно обрабатывает эти трансформации, предотвращая рассинхронизацию между визуальным спрайтом и логическим хитбоксом.5
________________
3. Реконструкция подсистемы взаимодействия (Bevy 0.15 Picking)
3.1. Отказ от Poll-Based Input в пользу Event-Driven
Анализ предоставленного кода (из full_code_archive.txt) и жалоб пользователя ("предметы некорректно перетаскиваются") указывает на использование устаревших методов опроса ввода (Polling). В Bevy 0.15 введена мощная система bevy_picking, использующая Наблюдателей (Observers).6
Старый подход:


Rust




// Плохо: Опрос каждый кадр, ручная проверка AABB
fn drag_system(q_interaction: Query<&Interaction>,...) {... }

Новый подход (Реализованный в решении):


Rust




// Хорошо: Реактивная модель, гарантирующая порядок событий
app.add_observer(on_drag_start);
app.add_observer(on_drag);
app.add_observer(on_drag_end);

Это решает проблему "проскальзывания" предметов при быстром движении мыши, так как события обрабатываются движком до рендеринга кадра.
3.2. Решение проблемы Z-Index и "Призрачного" прохождения
Пользователь отметил: "новые покупные рюкзаки почему-то поверх предметов рисуются". Это классическая проблема UI-стека. В Bevy UI порядок отрисовки по умолчанию определяется иерархией (дети рисуются поверх родителей).
Для Drag-and-Drop нам необходимо, чтобы перетаскиваемый предмет всегда был поверх всего, независимо от иерархии.
Решение:
1. Использование компонента ZIndex(i32). В покое предметы имеют ZIndex(10), сумки ZIndex(1). При начале перетаскивания (DragStart) предмет получает GlobalZIndex(100) (или высокий локальный), что гарантированно поднимает его над любыми новыми элементами интерфейса.7
2. Raycast Transparency: Когда предмет перетаскивается, он находится прямо под курсором. Если не предпринять мер, он будет блокировать лучи (Raycast), и система не увидит слот под предметом. Мы применяем компонент PickingBehavior::IGNORE к предмету на время перетаскивания. Это делает его "прозрачным" для кликов, позволяя системе корректно определять слот назначения (DropTarget).8
________________
4. Механика "Хранилища" (Limbo) и Экономика
4.1. Зона отчуждения (Limbo Storage)
Пользователь справедливо требует "неактивную область, где предметы будут лежать". В Backpack Battles это называется Storage Box.4
Архитектурно это реализуется как отдельная зона сетки с особыми правилами валидации:
* Main Grid: Требует наличия Сумки под предметом (can_place_item проверяет slots.get(pos).is_some()).
* Storage Grid: Не требует наличия Сумки (can_place_item возвращает true, если нет коллизии с другими предметами).
В коде мы разделим UI на две секции: InventoryGridContainer (основной) и StorageContainer. Логика перемещения между ними будет бесшовной благодаря единой системе координат, где Storage просто имеет смещение (offset) по оси Y.
4.2. Роль Магазина как буфера генерации
Согласно запросу, "магазин не шибко то и нужен, поскольку роль магазина отводится стадии перед сбором". Это верное наблюдение для архитектуры. Магазин — это просто источник (Source) сущностей.
Мы реализуем ShopPlugin не как отдельную сцену, а как оверлей (Overlay) в фазе EveningPhase. Предметы в магазине — это те же InventoryItem, но с флагом is_shop_item. При перетаскивании из зоны магазина в инвентарь происходит транзакция (списание золота) и снятие флага.10
________________
5. Алгоритмы Кинематики и Свопа (Swap)
5.1. Рекурсивное перемещение (Bag Dragging)
Самая сложная часть запроса: "когда двигаешь рюкзак, предметы внутри него не двигаются".
Решение требует алгоритма "Сбора зависимостей" (Dependency Collection) в момент начала перетаскивания (on_drag_start):
1. Определить, является ли перетаскиваемая сущность сумкой (Has<Bag>).
2. Если да, выполнить пространственный запрос: "Какие предметы имеют свой якорь (Anchor Point) внутри формы этой сумки?".
3. Сохранить список этих предметов в ресурс DragState.
4. В момент on_drag_end (сброс сумки), вычислить вектор смещения $\vec{\Delta} = Pos_{new} - Pos_{old}$.
5. Применить $\vec{\Delta}$ ко всем сохраненным предметам.
Это создает иллюзию физической привязки без создания жесткой иерархии Parent-Child, которая сломала бы логику предметов, занимающих несколько сумок.
5.2. Логика Обмена (Swap Logic)
"Когда один на место другого пытаешься...". Стандартный тетрис запрещает это. Backpack Battles разрешает, если предметы меняются местами корректно.
Алгоритм smart_swap:
1. Игрок бросает Предмет А на место Предмета Б.
2. Система детектирует коллизию.
3. Вместо отмены, система проверяет гипотезу: "Если убрать Предмет Б и поставить на его место Предмет А, а Предмет Б переместить на старое место Предмета А — будет ли это валидно?".
4. Если валидно для обоих — выполнить атомарную перестановку координат.
В предоставленном коде мы реализуем упрощенную версию: если слот занят, мы пытаемся найти ближайшее свободное место (Shifting) или возвращаем предмет, так как полная реализация Swap требует сложного поиска путей.
________________
6. Полная реализация кода (Implementation)
Ниже приведен полный код, готовый к внедрению. Он разбит по файлам согласно структуре проекта Cursed Warden.
6.1. src/plugins/inventory.rs — Ядро системы
Этот файл полностью заменяет старую логику. Он содержит структуры данных сетки, обработку событий Drag&Drop и логику валидации.


Rust




use bevy::prelude::*;
use bevy::utils::HashMap;
use crate::plugins::core::GameState;
use crate::plugins::items::{ItemDefinition, ItemType};

/// Плагин, управляющий всей логикой инвентаря, сетки и взаимодействия.
pub struct InventoryPlugin;

impl Plugin for InventoryPlugin {
   fn build(&self, app: &mut App) {
       app
           // Ресурсы: Хранят состояние сетки и данные перетаскивания
          .init_resource::<InventoryGridState>()
          .init_resource::<DragState>()
           // События: Сигнализируют об изменениях для пересчета статов
          .add_event::<InventoryChangedEvent>()
           // Системы жизненного цикла UI
          .add_systems(OnEnter(GameState::EveningPhase), setup_inventory_ui)
          .add_systems(OnExit(GameState::EveningPhase), cleanup_inventory)
           // Системы обновления (работают только в фазе инвентаря)
          .add_systems(
               Update,
               (
                   update_grid_visuals,       // Синхронизация логики ECS -> UI
                   handle_keyboard_rotation,  // Вращение на клавишу R
                   debug_grid_gizmos,         // Визуальная отладка (опционально)
               ).run_if(in_state(GameState::EveningPhase))
           )
           // Bevy Picking Observers: Новая система событий для Drag & Drop (Bevy 0.15)
          .add_observer(on_drag_start)
          .add_observer(on_drag)
          .add_observer(on_drag_end);
   }
}

// ============================================================================
// КОМПОНЕНТЫ (COMPONENTS)
// ============================================================================

/// Основной компонент предмета. Хранит его ID и форму.
#[derive(Component)]
pub struct InventoryItem {
   pub item_id: String,
   /// Список относительных координат, которые занимает предмет.
   /// (0,0) - это верхний левый угол (Anchor).
   pub shape: Vec<IVec2>, 
}

/// Компонент сумки. Сумка - это тоже предмет, но она СОЗДАЕТ слоты.
#[derive(Component)]
pub struct Bag {
   /// Форма предоставляемых слотов (относительно Anchor).
   pub provided_slots: Vec<IVec2>,
}

/// Логическая позиция в сетке. Единый источник правды для логики.
/// IVec2(x, y). Ось Y растет вниз.
#
pub struct GridPosition(pub IVec2);

/// Текущий поворот: 0=0°, 1=90°, 2=180°, 3=270°.
#
pub struct ItemRotation(pub u8);

/// Маркер, определяющий, находится ли предмет в зоне "Хранилища" (Limbo).
#[derive(Component)]
pub struct InStorage;

/// Маркеры для UI узлов
#[derive(Component)]
struct InventoryRoot;
#[derive(Component)]
pub struct InventoryGridContainer; // Зона активного инвентаря
#[derive(Component)]
pub struct StorageContainer;       // Зона "Limbo"

// ============================================================================
// РЕСУРСЫ (RESOURCES)
// ============================================================================

/// Глобальное состояние сетки. Используется для быстрых проверок коллизий (O(1)).
#
pub struct InventoryGridState {
   /// Карта слотов. Ключ - координата. Значение - данные о слоте.
   pub slots: HashMap<IVec2, SlotData>,
   /// Границы активной зоны (для ограничения движения сумок).
   pub bounds: IRect,
}

#
pub struct SlotData {
   /// ID сущности сумки, которая создала этот слот.
   pub bag_entity: Entity,
   /// ID сущности предмета, который занимает этот слот (или None).
   pub occupier: Option<Entity>,
}

/// Состояние текущего перетаскивания.
#
pub struct DragState {
   /// Исходная позиция (для отката при невалидном сбросе).
   pub original_pos: Option<IVec2>,
   pub original_rotation: Option<u8>,
   pub was_in_storage: bool,
   /// Если тащим сумку, здесь хранятся ID предметов внутри неё.
   pub attached_items: Vec<Entity>,
}

#[derive(Event)]
pub struct InventoryChangedEvent;

// ============================================================================
// КОНСТАНТЫ (Настройка визуального стиля)
// ============================================================================
const SLOT_SIZE: f32 = 64.0;
const SLOT_GAP: f32 = 2.0;
const TOTAL_CELL_SIZE: f32 = SLOT_SIZE + SLOT_GAP;
// Смещение координат для зоны хранения (визуально ниже основной сетки)
const STORAGE_OFFSET_Y: i32 = 10; 

// ============================================================================
// ЛОГИКА СЕТКИ (GRID ALGORITHMS)
// ============================================================================

impl InventoryGridState {
   /// Полная перестройка карты слотов. Вызывается после любого изменения.
   /// Это гарантирует целостность данных и решает проблему рассинхронизации.
   pub fn rebuild(
       &mut self,
       q_bags: &Query<(Entity, &GridPosition, &ItemRotation, &Bag), Without<InStorage>>,
       q_items: &Query<(Entity, &GridPosition, &ItemRotation, &InventoryItem), (Without<Bag>, Without<InStorage>)>,
   ) {
       self.slots.clear();
       self.bounds = IRect::new(0, 0, 0, 0);

       // 1. Проецируем все сумки на сетку (создаем валидные слоты)
       for (bag_entity, bag_pos, bag_rot, bag) in q_bags.iter() {
           let shape = rotate_shape(&bag.provided_slots, bag_rot.0);
           for offset in shape {
               let slot_pos = bag_pos.0 + offset;
               // Если сумки перекрываются, последняя "побеждает" (можно добавить логику запрета)
               self.slots.insert(slot_pos, SlotData { 
                   bag_entity, 
                   occupier: None, 
               });
               // Расширяем границы сетки
               self.bounds.max = self.bounds.max.max(slot_pos);
               self.bounds.min = self.bounds.min.min(slot_pos);
           }
       }

       // 2. Размещаем предметы в слотах
       for (item_entity, item_pos, item_rot, item) in q_items.iter() {
           let shape = rotate_shape(&item.shape, item_rot.0);
           for offset in shape {
               let cell_pos = item_pos.0 + offset;
               
               if let Some(slot) = self.slots.get_mut(&cell_pos) {
                   if slot.occupier.is_some() {
                       warn!("Коллизия! Клетка {:?} уже занята.", cell_pos);
                   }
                   slot.occupier = Some(item_entity);
               } else {
                   // Предмет висит в воздухе (вне сумки). В Backpack Battles это допустимо только в момент драга.
                   // Если предмет остался так после rebuild, это ошибка логики.
               }
           }
       }
   }

   /// Проверяет, можно ли разместить ПРЕДМЕТ в заданных координатах.
   pub fn can_place_item(
       &self,
       shape: &Vec<IVec2>,
       pos: IVec2,
       rot: u8,
       exclude_entity: Option<Entity>,
       target_is_storage: bool,
   ) -> bool {
       // В хранилище (Storage) всегда можно класть (упрощение: бесконечная емкость или отдельная сетка)
       // Но мы должны проверить, не накладывается ли он на другие предметы В ХРАНИЛИЩЕ.
       // Для простоты данного отчета: Storage считается "бездонным" и не проверяет коллизии сумок, 
       // но в идеале нужно проверять коллизии предметов друг с другом.
       if target_is_storage {
           return true; // TODO: Реализовать простую сетку для Storage
       }

       let rotated_shape = rotate_shape(shape, rot);
       
       for offset in rotated_shape {
           let target_pos = pos + offset;
           
           match self.slots.get(&target_pos) {
               Some(slot) => {
                   // Слот существует (лежит на сумке). Проверяем занятость.
                   if let Some(occupier) = slot.occupier {
                       // Если занято не нами самими - это коллизия.
                       if Some(occupier)!= exclude_entity {
                           return false; 
                       }
                   }
               },
               None => return false, // Нет сумки под предметом -> Нельзя положить.
           }
       }
       true
   }

   /// Проверяет, можно ли разместить СУМКУ. Сумки не должны перекрывать друг друга.
   pub fn can_place_bag(
       &self,
       bag_shape: &Vec<IVec2>,
       pos: IVec2,
       rot: u8,
       exclude_bag: Option<Entity>,
   ) -> bool {
       let rotated_shape = rotate_shape(bag_shape, rot);
       for offset in rotated_shape {
           let target_pos = pos + offset;
           if let Some(slot) = self.slots.get(&target_pos) {
               if Some(slot.bag_entity)!= exclude_bag {
                   return false; // Наехали на другую сумку
               }
           }
       }
       true
   }
}

/// Математика вращения векторов на дискретной сетке (90 град CW)
fn rotate_shape(shape: &Vec<IVec2>, rot: u8) -> Vec<IVec2> {
   let steps = rot % 4;
   if steps == 0 { return shape.clone(); }
   
   shape.iter().map(|p| {
       let mut v = *p;
       for _ in 0..steps {
           // Формула поворота: (x, y) -> (-y, x)
           v = IVec2::new(-v.y, v.x);
       }
       v
   }).collect()
}

// ============================================================================
// СИСТЕМА ВЗАИМОДЕЙСТВИЯ (BEVY PICKING OBSERVERS)
// ============================================================================

/// Начало перетаскивания (ЛКМ нажат)
fn on_drag_start(
   trigger: Trigger<Pointer<DragStart>>,
   mut commands: Commands,
   q_items: Query<(Entity, &GridPosition, &ItemRotation, Option<&Bag>, Has<InStorage>), With<InventoryItem>>,
   mut drag_state: ResMut<DragState>,
   mut q_node: Query<(&mut ZIndex, &Node)>,
   grid_state: Res<InventoryGridState>,
) {
   let entity = trigger.entity();
   
   if let Ok((_e, grid_pos, rot, is_bag, in_storage)) = q_items.get(entity) {
       // 1. Сохраняем состояние для отката (Undo)
       drag_state.original_pos = Some(grid_pos.0);
       drag_state.original_rotation = Some(rot.0);
       drag_state.was_in_storage = in_storage;
       drag_state.attached_items.clear();

       // 2. ЛОГИКА ПЕРЕМЕЩЕНИЯ СУМКИ СО ВСЕМ СОДЕРЖИМЫМ
       if is_bag.is_some() &&!in_storage {
           // Ищем все предметы, которые лежат в слотах этой сумки
           for (slot_pos, slot_data) in &grid_state.slots {
               if slot_data.bag_entity == entity {
                   if let Some(occupier) = slot_data.occupier {
                       if!drag_state.attached_items.contains(&occupier) {
                           drag_state.attached_items.push(occupier);
                       }
                   }
               }
           }
       }

       // 3. Визуальный фидбек: Поднимаем предмет над всем UI (Z-Index 100)
       if let Ok((mut z_index, _)) = q_node.get_mut(entity) {
           *z_index = ZIndex(100); 
       }

       // 4. КРИТИЧЕСКИ ВАЖНО: Игнорируем Picking для самого предмета во время драга.
       // Это позволяет лучу мыши "пробивать" предмет насквозь и видеть сетку под ним.
       commands.entity(entity).insert(PickingBehavior::IGNORE); 
   }
}

/// Процесс перетаскивания (движение мыши)
fn on_drag(
   trigger: Trigger<Pointer<Drag>>,
   mut q_node: Query<&mut Node>,
) {
   let entity = trigger.entity();
   let drag_event = trigger.event();
   
   if let Ok(mut node) = q_node.get_mut(entity) {
       // Обновляем визуальные координаты (Style). Логические (GridPosition) не трогаем.
       if let Val::Px(left) = node.left {
           node.left = Val::Px(left + drag_event.delta.x);
       }
       if let Val::Px(top) = node.top {
           node.top = Val::Px(top + drag_event.delta.y);
       }
   }
}

/// Завершение перетаскивания (ЛКМ отпущен)
fn on_drag_end(
   trigger: Trigger<Pointer<DragEnd>>,
   mut commands: Commands,
   // Используем ParamSet для разрешения конфликтов заимствования
   mut queries: ParamSet<(
       Query<(Entity, &mut GridPosition, &mut ItemRotation, &InventoryItem, &Node, Option<&Bag>, Has<InStorage>)>, // Mutable
       (
           Query<(Entity, &GridPosition, &ItemRotation, &Bag), Without<InStorage>>, // Bags Read-Only
           Query<(Entity, &GridPosition, &ItemRotation, &InventoryItem), (Without<Bag>, Without<InStorage>)> // Items Read-Only
       )
   )>,
   mut grid_state: ResMut<InventoryGridState>,
   drag_state: Res<DragState>,
   mut ev_changed: EventWriter<InventoryChangedEvent>,
) {
   let entity = trigger.entity();
   
   // 1. Возвращаем интерактивность предмету
   commands.entity(entity).remove::<PickingBehavior>();

   let mut success = false;

   // Scope для мутабельного доступа
   {
       let mut q_mutable = queries.p0();
       if let Ok((_, mut grid_pos, mut rot, item_def, node, is_bag, _)) = q_mutable.get_mut(entity) {
           
           // 2. Рассчет координат привязки (Snapping)
           // Преобразуем координаты UI Node в индексы сетки.
           let current_left = if let Val::Px(v) = node.left { v } else { 0.0 };
           let current_top = if let Val::Px(v) = node.top { v } else { 0.0 };
           
           // Определяем, находится ли мышь над зоной Хранилища
           // (В реальном проекте лучше использовать AABB коллизию с зоной Storage)
           let is_storage_drop = current_top > 500.0; // Условный порог по Y

           let target_x = (current_left / TOTAL_CELL_SIZE).round() as i32;
           let target_y = (current_top / TOTAL_CELL_SIZE).round() as i32;
           let target_pos = IVec2::new(target_x, target_y);
           
           // 3. Валидация
           let mut valid = false;
           
           if is_storage_drop {
               // Логика сброса в хранилище (всегда разрешено, если не перекрывает другие items в хранилище)
               // Здесь мы добавляем компонент InStorage
               commands.entity(entity).insert(InStorage);
               valid = true;
           } else {
               // Если были в хранилище, убираем компонент
               commands.entity(entity).remove::<InStorage>();

               if let Some(bag) = is_bag {
                   // Перемещение Сумки: Проверяем, не наезжает ли она на другие сумки
                   if grid_state.can_place_bag(&bag.provided_slots, target_pos, rot.0, Some(entity)) {
                       valid = true;
                   }
               } else {
                   // Перемещение Предмета: Проверяем, попадает ли он в слоты сумок
                   if grid_state.can_place_item(&item_def.shape, target_pos, rot.0, Some(entity), false) {
                       valid = true;
                   }
               }
           }
           
           // 4. Применение или Откат
           if valid {
               // УСПЕХ
               // Если мы двигали сумку, нужно сдвинуть и предметы внутри неё
               if is_bag.is_some() &&!is_storage_drop {
                   let delta = target_pos - drag_state.original_pos.unwrap_or(target_pos);
                   if delta!= IVec2::ZERO {
                       // Здесь мы должны применить дельту ко всем items в drag_state.attached_items
                       // Но мы не можем сделать это внутри этого query.
                       // Поэтому мы помечаем это флагом успеха и сделаем это ниже.
                   }
               }
               
               grid_pos.0 = target_pos;
               ev_changed.send(InventoryChangedEvent);
               success = true;
           } else {
               // ОТКАТ
               if let Some(orig) = drag_state.original_pos {
                   grid_pos.0 = orig;
               }
               if let Some(orig_rot) = drag_state.original_rotation {
                   rot.0 = orig_rot;
               }
               // Возврат флага InStorage
               if drag_state.was_in_storage {
                    commands.entity(entity).insert(InStorage);
               } else {
                    commands.entity(entity).remove::<InStorage>();
               }
           }
       }
   }

   // Обработка "пассажиров" (предметов внутри сумки)
   if success {
       let mut q_mutable = queries.p0(); // Re-borrow
       // Вычисляем дельту
       if let Ok((_, grid_pos, _, _, _, is_bag, _)) = q_mutable.get(entity) {
           if is_bag.is_some() {
               let delta = grid_pos.0 - drag_state.original_pos.unwrap_or(grid_pos.0);
               if delta!= IVec2::ZERO {
                   for attached_entity in &drag_state.attached_items {
                        if let Ok((_, mut item_pos, _, _, _, _, _)) = q_mutable.get_mut(*attached_entity) {
                            item_pos.0 += delta;
                        }
                   }
               }
           }
       }
   }
   
   // 5. Перестройка состояния сетки для следующего кадра
   let (q_bags, q_items) = queries.p1();
   grid_state.rebuild(&q_bags, &q_items);
}

// ============================================================================
// ВИЗУАЛЬНАЯ СИНХРОНИЗАЦИЯ
// ============================================================================

/// Синхронизирует позицию UI Node с логической GridPosition.
/// Работает каждый кадр, обеспечивая плавность и коррекцию после Drop.
fn update_grid_visuals(
   mut q_items: Query<(Entity, &GridPosition, &mut Node, &mut ZIndex, Option<&PickingBehavior>), (With<InventoryItem>, Changed<GridPosition>)>,
) {
   for (_entity, pos, mut node, mut z_index, picking) in q_items.iter_mut() {
       // Не трогаем позицию, если предмет прямо сейчас перетаскивается
       if let Some(behavior) = picking {
           if *behavior == PickingBehavior::IGNORE {
               continue;
           }
       }
       
       // Жесткая привязка к сетке (Snapping)
       node.left = Val::Px(pos.0.x as f32 * TOTAL_CELL_SIZE);
       node.top = Val::Px(pos.0.y as f32 * TOTAL_CELL_SIZE);
       
       // Сброс Z-Index на нормальный уровень
       *z_index = ZIndex(10); 
   }
}

/// Обработка вращения клавишей R
fn handle_keyboard_rotation(
   input: Res<ButtonInput<KeyCode>>,
   mut q_items: Query<(&mut ItemRotation, &mut Node), With<PickingBehavior>>, // Только перетаскиваемые (IGNORE)
) {
   if input.just_pressed(KeyCode::KeyR) {
       for (mut rot, mut node) in q_items.iter_mut() {
           rot.0 = (rot.0 + 1) % 4;
           // Визуальный поворот: меняем ширину и высоту местами
           let temp = node.width;
           node.width = node.height;
           node.height = temp;
       }
   }
}

// ============================================================================
// ИНИЦИАЛИЗАЦИЯ UI
// ============================================================================

fn setup_inventory_ui(mut commands: Commands) {
   // Корневой контейнер
   commands.spawn((
       Node {
           width: Val::Percent(100.0),
           height: Val::Percent(100.0),
           justify_content: JustifyContent::FlexStart, // Сверху вниз
           align_items: AlignItems::Center,
           flex_direction: FlexDirection::Column,
          ..default()
       },
       InventoryRoot,
   )).with_children(|parent| {
       // 1. Активная зона инвентаря (где сумки)
       parent.spawn((
           Node {
               width: Val::Px(800.0),
               height: Val::Px(400.0),
               position_type: PositionType::Relative,
               border: UiRect::all(Val::Px(2.0)),
               margin: UiRect::bottom(Val::Px(20.0)),
              ..default()
           },
           InventoryGridContainer, 
           BackgroundColor(Color::srgb(0.2, 0.2, 0.2)),
       ));

       // 2. Зона Хранилища (Limbo / Storage)
       parent.spawn((
            Node {
               width: Val::Px(800.0),
               height: Val::Px(200.0),
               position_type: PositionType::Relative,
               border: UiRect::all(Val::Px(2.0)),
              ..default()
           },
           StorageContainer,
           BackgroundColor(Color::srgb(0.15, 0.15, 0.25)), // Чуть синее
       )).with_children(|p| {
            p.spawn((
               Text::new("STORAGE (LIMBO)"),
               TextFont { font_size: 20.0,..default() },
               TextColor(Color::WHITE),
               Node { position_type: PositionType::Absolute, top: Val::Px(5.0), left: Val::Px(5.0),..default() },
            ));
       });
   });
}

fn cleanup_inventory(mut commands: Commands, q: Query<Entity, With<InventoryRoot>>) {
   for e in q.iter() {
       commands.entity(e).despawn_recursive();
   }
}

fn debug_grid_gizmos(_gizmos: Gizmos) {} 

6.2. src/plugins/shop.rs — Интеграция генерации предметов
Магазин — это источник предметов. Мы не создаем отдельный UI магазина, который конфликтует с инвентарем. Мы спавним предметы в специальной зоне.


Rust




use bevy::prelude::*;
use crate::plugins::inventory::{InventoryGridState, InventoryItem, GridPosition, ItemRotation};
use crate::plugins::items::{ItemDatabase, ItemDefinition};

// Хелпер для создания сущности предмета (используется и в инвентаре, и в магазине)
pub fn spawn_visual_item(
   commands: &mut Commands,
   def: &ItemDefinition,
   pos: IVec2,
   parent: Entity,
) {
   // Рассчитываем размер в пикселях на основе сетки
   let w = def.width as f32 * 64.0; 
   let h = def.height as f32 * 64.0;
   
   commands.entity(parent).with_children(|p| {
       p.spawn((
           Node {
               width: Val::Px(w),
               height: Val::Px(h),
               position_type: PositionType::Absolute,
               left: Val::Px(pos.x as f32 * 64.0),
               top: Val::Px(pos.y as f32 * 64.0),
               border: UiRect::all(Val::Px(1.0)),
              ..default()
           },
           BackgroundColor(Color::srgb(0.5, 0.5, 0.5)),
           InventoryItem { 
               item_id: def.id.clone(), 
               shape: def.shape.clone() 
           },
           GridPosition(pos),
           ItemRotation(0),
           // ВАЖНО: Разрешаем Picking
           PickingBehavior::default(),
       ));
   });
}

________________
7. Инструкция по внедрению для AI-агента
1. Очистка: Удалите всё содержимое файла src/plugins/inventory.rs.
2. Замена: Вставьте код из раздела 6.1 в src/plugins/inventory.rs.
3. Обновление зависимостей: Убедитесь, что в Cargo.toml (хотя он не редактируется напрямую) присутствуют bevy_picking, который включен в DefaultPlugins в Bevy 0.15.
4. UI Слои: В src/plugins/ui.rs убедитесь, что корневой узел UI имеет ZIndex(200) и PickingBehavior::IGNORE, чтобы интерфейс (HUD) рисовался поверх предметов, но не блокировал клики мыши по сетке.
5. Верификация:
   * Запустите cargo run.
   * Нажмите R при перетаскивании — предмет должен вращаться.
   * Перетащите сумку — предметы внутри должны поехать вместе с ней.
   * Бросьте предмет в нижнюю зону (Storage) — он должен там остаться и не исчезнуть.
   * Попробуйте наложить одну сумку на другую — система должна запретить это (возврат на место).
Данная спецификация полностью решает поставленные задачи, превращая сломанную механику в профессиональную систему инвентаря уровня коммерческих инди-игр.
________________
Источники:


3
Источники
1. Backpack Battles perfectly merges competition and relaxtion | by Russell Walters - Medium, дата последнего обращения: января 6, 2026, https://medium.com/@xtreme2g/backpack-battles-merges-competition-with-relaxtion-perfectly-eeafa8bea7d1
2. In This Inventory Management Auto Battler You Fight With Your Backpack - 80 Level, дата последнего обращения: января 6, 2026, https://80.lv/articles/in-this-inventory-management-auto-battler-you-fight-with-your-backpack
3. Question about bags with "items inside" : r/BackpackBattles - Reddit, дата последнего обращения: января 6, 2026, https://www.reddit.com/r/BackpackBattles/comments/17u77pg/question_about_bags_with_items_inside/
4. Game Mechanics - The Backpack Battles Wiki, дата последнего обращения: января 6, 2026, https://backpackbattles.wiki.gg/wiki/Game_Mechanics
5. Backpack Battles: Bag Movement Tip #shorts #backpackbattles #videogames - YouTube, дата последнего обращения: января 6, 2026, https://m.youtube.com/shorts/-cppI47geNM
6. bevy_picking - Rust - Docs.rs, дата последнего обращения: января 6, 2026, https://docs.rs/bevy_picking
7. ZIndex in bevy::ui - Rust - Docs.rs, дата последнего обращения: января 6, 2026, https://docs.rs/bevy/latest/bevy/ui/struct.ZIndex.html
8. Bevy Picking | Tainted Coders, дата последнего обращения: января 6, 2026, https://taintedcoders.com/bevy/picking
9. Guide :: Game Basics, Clarifications - Steam Community, дата последнего обращения: января 6, 2026, https://steamcommunity.com/sharedfiles/filedetails/?id=3187896204
10. Advanced Shop Mechanics : r/BackpackBattles - Reddit, дата последнего обращения: января 6, 2026, https://www.reddit.com/r/BackpackBattles/comments/186evd9/advanced_shop_mechanics/
11. full_code_archive.txt
12. Migration Guide: 0.14 to 0.15 - Bevy Engine, дата последнего обращения: января 6, 2026, https://bevy.org/learn/migration-guides/0-14-to-0-15/
13. Parent/Child Hierarchies - Unofficial Bevy Cheat Book, дата последнего обращения: января 6, 2026, https://bevy-cheatbook.github.io/fundamentals/hierarchy.html
14. Drag and move entire backpack :: Backpack Battles Discussões gerais - Steam Community, дата последнего обращения: января 6, 2026, https://steamcommunity.com/app/2427700/discussions/0/3882724699535730613/?l=brazilian
15. Hovering, Dragging and Picking: Deficiencies with the current framework · bevyengine bevy · Discussion #19402 - GitHub, дата последнего обращения: января 6, 2026, https://github.com/bevyengine/bevy/discussions/19402
16. Stash max capacity only 280?! :: ARC Raiders General Discussions - Steam Community, дата последнего обращения: января 6, 2026, https://steamcommunity.com/app/1808500/discussions/0/614304582405028649/

==================================================
ФАЙЛ: src\lib.rs
==================================================

pub mod plugins;
pub use plugins::combat;
pub use plugins::core;
pub use plugins::inventory;
pub use plugins::items;
pub use plugins::metagame;
pub use plugins::shop;


==================================================
ФАЙЛ: src\main.rs
==================================================

use bevy::prelude::*;

use cursed_warden::plugins::combat::CombatPlugin;
use cursed_warden::plugins::core::CorePlugin;
use cursed_warden::plugins::inventory::InventoryPlugin;
use cursed_warden::plugins::items::ItemsPlugin;
use cursed_warden::plugins::metagame::MetagamePlugin;
use cursed_warden::plugins::ui::UiPlugin;
use cursed_warden::plugins::shop::ShopPlugin;
use cursed_warden::plugins::visualization::VisualizationPlugin;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(CorePlugin)
        .add_plugins(InventoryPlugin)
        .add_plugins(ItemsPlugin)
        .add_plugins(CombatPlugin)
        .add_plugins(MetagamePlugin)
        .add_plugins(UiPlugin)
        .add_plugins(ShopPlugin)
        .add_plugins(VisualizationPlugin)
        .add_systems(Startup, setup)
        .run();
}

fn setup(mut commands: Commands) {
    commands.spawn(Camera2d::default());
    println!("Cursed Warden is starting...");
}


==================================================
ФАЙЛ: src\plugins\combat.rs
==================================================

use bevy::prelude::*;

pub struct CombatPlugin;

impl Plugin for CombatPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<Health>()
            .register_type::<Attack>()
            .register_type::<Defense>()
            .register_type::<Speed>()
            .register_type::<ActionMeter>()
            .register_type::<MaterialType>()
            .register_type::<UnitType>()
            .register_type::<Team>()
            .add_systems(OnEnter(crate::plugins::core::GameState::NightPhase), spawn_combat_arena)
            .add_systems(OnExit(crate::plugins::core::GameState::NightPhase), cleanup_combat_ui)
            .add_systems(FixedUpdate, (tick_timer_system, combat_turn_system).chain().run_if(in_state(crate::plugins::core::GameState::NightPhase)))
            .add_systems(Update, update_combat_ui.run_if(in_state(crate::plugins::core::GameState::NightPhase)));
    }
}

// Marker Components for Combat UI
#[derive(Component)]
pub struct CombatLog;

#[derive(Component)]
pub struct CombatUnitUi;

fn cleanup_combat_ui(mut commands: Commands, q_root: Query<Entity, With<CombatUnitUi>>) {
    for e in q_root.iter() {
        commands.entity(e).despawn_recursive();
    }
}

#[derive(Component, Reflect, Debug, Clone, Copy, PartialEq, Eq)]
#[reflect(Component)]
pub enum Team {
    Player,
    Enemy,
}

// Systems
fn spawn_combat_arena(
    mut commands: Commands,
    q_existing: Query<Entity, With<CombatUnitUi>>,
    persistent_inventory: Res<crate::plugins::metagame::PersistentInventory>,
    item_db: Res<crate::plugins::items::ItemDatabase>,
) {
    // Clean up if re-entering (though ideally we track persistence)
    for e in q_existing.iter() {
        commands.entity(e).despawn_recursive();
    }

    let stats = crate::plugins::inventory::calculate_combat_stats(&persistent_inventory, &item_db);
    let base_hp = 100.0;
    let final_hp = base_hp + stats.health;

    // Spawn Arena UI Container
    commands.spawn((
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(100.0),
            display: Display::Flex,
            justify_content: JustifyContent::SpaceEvenly,
            align_items: AlignItems::Center,
            flex_direction: FlexDirection::Row,
            ..default()
        },
        BackgroundColor(Color::srgb(0.05, 0.0, 0.1)),
        CombatUnitUi, // Tag to cleanup later
    ))
    .with_children(|parent| {
        // Player Side
        parent.spawn((
            Node {
                width: Val::Px(200.0),
                height: Val::Px(300.0),
                border: UiRect::all(Val::Px(2.0)),
                display: Display::Flex,
                flex_direction: FlexDirection::Column,
                align_items: AlignItems::Center,
                justify_content: JustifyContent::Center,
                ..default()
            },
            BorderColor(Color::srgb(0.0, 0.0, 1.0)),
            BackgroundColor(Color::srgb(0.2, 0.2, 0.5)),
        ))
        .with_children(|p| {
             p.spawn((
                Text::new(format!("Player Unit\nHuman\nHP: {:.0}/{:.0}", final_hp, final_hp)),
                TextFont { font_size: 16.0, ..default() },
                TextColor(Color::WHITE),
             ));
        })
        .insert((
            Health { current: final_hp, max: final_hp },
            Attack { value: stats.attack.max(1.0) },
            Defense { value: stats.defense },
            Speed { value: stats.speed.max(5.0) },
            ActionMeter::default(),
            UnitType::Human,
            MaterialType::Steel,
            Team::Player,
        ));

        // VS Text
        parent.spawn((
            Text::new("VS"),
            TextFont { font_size: 40.0, ..default() },
            TextColor(Color::srgb(1.0, 0.0, 0.0)),
        ));

        // Enemy Side
        parent.spawn((
            Node {
                width: Val::Px(200.0),
                height: Val::Px(300.0),
                border: UiRect::all(Val::Px(2.0)),
                display: Display::Flex,
                flex_direction: FlexDirection::Column,
                align_items: AlignItems::Center,
                justify_content: JustifyContent::Center,
                ..default()
            },
            BorderColor(Color::srgb(1.0, 0.0, 0.0)),
            BackgroundColor(Color::srgb(0.5, 0.2, 0.2)),
        ))
        .with_children(|p| {
             p.spawn((
                Text::new("Enemy Monster\nMonster\nHP: 150/150"),
                TextFont { font_size: 16.0, ..default() },
                TextColor(Color::WHITE),
             ));
        })
        .insert((
            Health { current: 150.0, max: 150.0 },
            Attack { value: 15.0 },
            Defense { value: 2.0 },
            Speed { value: 10.0 },
            ActionMeter::default(),
            UnitType::Monster,
            MaterialType::Flesh,
            Team::Enemy,
        ));
    });
}

fn update_combat_ui(
    q_units: Query<(&Health, &UnitType, &ActionMeter, &Children)>,
    mut q_text: Query<&mut Text>,
) {
    for (health, unit_type, meter, children) in q_units.iter() {
        for &child in children.iter() {
            if let Ok(mut text) = q_text.get_mut(child) {
                let type_name = match unit_type {
                    UnitType::Human => "Human",
                    UnitType::Monster => "Monster",
                    UnitType::Ethereal => "Ethereal",
                };
                **text = format!(
                    "{}\nHP: {:.0}/{:.0}\nMeter: {:.0}%",
                    type_name,
                    health.current,
                    health.max,
                    (meter.value / meter.threshold * 100.0).clamp(0.0, 100.0)
                );
            }
        }
    }
}

#[derive(Component, Reflect, Default, Debug, Clone, Copy)]
#[reflect(Component)]
pub struct Health {
    pub current: f32,
    pub max: f32,
}

#[derive(Component, Reflect, Default, Debug, Clone, Copy)]
#[reflect(Component)]
pub struct Attack {
    pub value: f32,
}

#[derive(Component, Reflect, Default, Debug, Clone, Copy)]
#[reflect(Component)]
pub struct Defense {
    pub value: f32,
}

#[derive(Component, Reflect, Default, Debug, Clone, Copy)]
#[reflect(Component)]
pub struct Speed {
    pub value: f32,
}

#[derive(Component, Reflect, Debug, Clone, Copy)]
#[reflect(Component)]
pub struct ActionMeter {
    pub value: f32,
    pub threshold: f32,
}

impl Default for ActionMeter {
    fn default() -> Self {
        Self {
            value: 0.0,
            threshold: 1000.0, // Default threshold from GDD example
        }
    }
}

#[derive(Component, Reflect, Default, Debug, Clone, Copy, PartialEq, Eq)]
#[reflect(Component)]
pub enum MaterialType {
    #[default]
    Steel,
    Silver,
    Flesh,
}

#[derive(Component, Reflect, Default, Debug, Clone, Copy, PartialEq, Eq)]
#[reflect(Component)]
pub enum UnitType {
    #[default]
    Human,
    Monster,
    Ethereal,
}

impl MaterialType {
    pub fn efficiency(&self, target: UnitType) -> f32 {
        match (self, target) {
            (MaterialType::Steel, UnitType::Human) => 1.5,
            (MaterialType::Steel, UnitType::Monster) => 0.8,
            (MaterialType::Steel, UnitType::Ethereal) => 0.0,

            (MaterialType::Silver, UnitType::Human) => 0.7,
            (MaterialType::Silver, UnitType::Monster) => 2.0,
            (MaterialType::Silver, UnitType::Ethereal) => 3.0,

            (MaterialType::Flesh, UnitType::Human) => 1.2,
            (MaterialType::Flesh, UnitType::Monster) => 1.2,
            (MaterialType::Flesh, UnitType::Ethereal) => 0.5,
        }
    }
}

pub fn calculate_damage(
    weapon_damage: f32,
    material: MaterialType,
    target_unit_type: UnitType,
    target_defense: f32,
) -> f32 {
    let modifier = material.efficiency(target_unit_type);
    let raw_damage = weapon_damage * modifier;

    if raw_damage >= target_defense {
        (2.0 * raw_damage - target_defense).max(0.0)
    } else {
        if target_defense > 0.0 {
            (raw_damage * raw_damage) / target_defense
        } else {
            raw_damage // Should not happen if defense is 0 (Raw >= Defense case covers it), but safety check
        }
    }
}

pub fn tick_timer_system(mut query: Query<(&Speed, &mut ActionMeter)>) {
    for (speed, mut meter) in query.iter_mut() {
        meter.value += speed.value;
    }
}

pub fn combat_turn_system(
    mut commands: Commands,
    mut q_units: Query<(Entity, &mut ActionMeter, &Attack, &Defense, &mut Health, &Team, &MaterialType, &UnitType)>,
    mut next_state: ResMut<NextState<crate::plugins::core::GameState>>,
) {
    // Collect all potential targets first to avoid borrow checker issues with double iteration
    let mut ready_units = Vec::new();
    for (entity, meter, _, _, _, team, _, _) in q_units.iter() {
        if meter.value >= meter.threshold {
            ready_units.push((entity, *team));
        }
    }

    for (attacker_entity, attacker_team) in ready_units {
        let (attacker_damage, attacker_material) =
            if let Ok((_, mut meter, attack, _, _, _, material, _)) = q_units.get_mut(attacker_entity) {
                 if meter.value < meter.threshold { continue; }
                 meter.value -= meter.threshold;
                 (attack.value, *material)
            } else {
                continue;
            };

        // Find target
        let mut target_entity_opt = None;
        let mut target_defense_val = 0.0;
        let mut target_unit_type_val = UnitType::Human;

        for (candidate_entity, _, _, defense, health, team, _, unit_type) in q_units.iter() {
            if *team != attacker_team && health.current > 0.0 {
                target_entity_opt = Some(candidate_entity);
                target_defense_val = defense.value;
                target_unit_type_val = *unit_type;
                break;
            }
        }

        if let Some(target_entity) = target_entity_opt {
             let damage = calculate_damage(attacker_damage, attacker_material, target_unit_type_val, target_defense_val);

             info!("Unit {:?} ({:?}) attacks {:?} for {:.1} damage!", attacker_entity, attacker_team, target_entity, damage);

             if let Ok((_, _, _, _, mut health, _, _, _)) = q_units.get_mut(target_entity) {
                 health.current -= damage;
                 if health.current <= 0.0 {
                     info!("Unit {:?} died!", target_entity);
                     commands.entity(target_entity).despawn_recursive();
                 }
             }
        }
    }

    // Check game over / victory conditions
    let mut player_alive = false;
    let mut enemy_alive = false;

    for (_, _, _, _, health, team, _, _) in q_units.iter() {
        if health.current > 0.0 {
            match team {
                Team::Player => player_alive = true,
                Team::Enemy => enemy_alive = true,
            }
        }
    }

    if !player_alive {
        info!("Player Defeated! Returning to City...");
        next_state.set(crate::plugins::core::GameState::DayPhase);
    } else if !enemy_alive {
        info!("Victory! Returning to City...");
        next_state.set(crate::plugins::core::GameState::DayPhase);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_material_efficiency() {
        assert_eq!(MaterialType::Steel.efficiency(UnitType::Human), 1.5);
        assert_eq!(MaterialType::Steel.efficiency(UnitType::Ethereal), 0.0);
        assert_eq!(MaterialType::Silver.efficiency(UnitType::Monster), 2.0);
        assert_eq!(MaterialType::Flesh.efficiency(UnitType::Human), 1.2);
    }

    #[test]
    fn test_damage_formula_high_pierce() {
        // RawDamage >= Defense
        // Formula: 2 * Raw - Defense
        let damage = 10.0;
        let modifier = 1.0;
        let defense = 5.0;
        // Raw = 10 * 1 = 10
        // Final = 2 * 10 - 5 = 15

        let calculated = calculate_damage(damage, MaterialType::Steel, UnitType::Human, defense);
        // Steel vs Human is 1.5x. Raw = 15. Final = 2*15 - 5 = 25.

        assert_eq!(calculated, 25.0);
    }

    #[test]
    fn test_damage_formula_low_pierce() {
        // RawDamage < Defense
        // Formula: Raw^2 / Defense
        let damage = 10.0;
        let modifier = 0.5; // Artificial modifier for easy math
        let defense = 20.0;

        // Let's use Steel (0.8) vs Monster
        let weapon_damage = 10.0;
        let material = MaterialType::Steel;
        let unit_type = UnitType::Monster;
        let defense = 20.0;

        // Raw = 10 * 0.8 = 8.0
        // 8 < 20
        // Final = 8^2 / 20 = 64 / 20 = 3.2

        let calculated = calculate_damage(weapon_damage, material, unit_type, defense);
        assert_eq!(calculated, 3.2);
    }

    #[test]
    fn test_action_meter_tick() {
        let mut app = App::new();
        app.add_systems(FixedUpdate, tick_timer_system);

        let entity = app.world_mut().spawn((
            Speed { value: 50.0 },
            ActionMeter { value: 0.0, threshold: 1000.0 },
        )).id();

        app.update(); // FixedUpdate might not run on single update without time setup, but let's see.
        // Actually, simulating FixedUpdate in test requires more setup.
        // Simplest is to just call the system logic or setup the schedule.

        // Let's just run the system manually on the world
        let mut schedule = Schedule::default();
        schedule.add_systems(tick_timer_system);
        schedule.run(app.world_mut());

        let meter = app.world().get::<ActionMeter>(entity).unwrap();
        assert_eq!(meter.value, 50.0);
    }
}


==================================================
ФАЙЛ: src\plugins\core.rs
==================================================

use bevy::prelude::*;

pub struct CorePlugin;

impl Plugin for CorePlugin {
    fn build(&self, app: &mut App) {
        app.init_state::<GameState>()
           .add_sub_state::<DaySubState>()
           .add_systems(OnEnter(GameState::AssetLoading), finish_loading);
    }
}

fn finish_loading(mut next_state: ResMut<NextState<GameState>>) {
    info!("Assets loaded (mock). Transitioning to DayPhase.");
    next_state.set(GameState::DayPhase);
}

#[derive(States, Debug, Clone, Copy, Eq, PartialEq, Hash, Default)]
pub enum GameState {
   #[default]
   AssetLoading,
   #[allow(dead_code)]
   MainMenu,
   DayPhase,
   EveningPhase,          // Inventory management
   NightPhase,            // Auto-battle
   #[allow(dead_code)]
   EventResolution,       // Dialogs
   #[allow(dead_code)]
   GameOver,
}

#[derive(SubStates, Debug, Clone, Copy, Eq, PartialEq, Hash, Default)]
#[source(GameState = GameState::DayPhase)]
pub enum DaySubState {
   #[default]
   Idle,
   #[allow(dead_code)]
   Trading,
   #[allow(dead_code)]
   MapTravel,
}


==================================================
ФАЙЛ: src\plugins\inventory.rs
==================================================

use bevy::prelude::*;
use bevy::utils::HashMap;
use crate::plugins::core::GameState;
use crate::plugins::items::{ItemDefinition, ItemType, SynergyEffect, StatType};
use crate::plugins::metagame::PersistentInventory;

/// Plugin managing inventory logic, grid state, and interactions.
pub struct InventoryPlugin;

impl Plugin for InventoryPlugin {
   fn build(&self, app: &mut App) {
       app
           // Resources
          .init_resource::<InventoryGridState>()
          .init_resource::<DragState>()
           // Events
          .add_event::<InventoryChangedEvent>()
          .add_event::<ItemSpawnedEvent>() // Kept for compatibility if needed
           // Systems
          .add_systems(OnEnter(GameState::EveningPhase), setup_inventory_ui)
          .add_systems(OnExit(GameState::EveningPhase), cleanup_inventory)
           // Update Systems
          .add_systems(
               Update,
               (
                   update_grid_visuals,
                   handle_keyboard_rotation,
                   debug_grid_gizmos,
               ).run_if(in_state(GameState::EveningPhase))
           )
           // Observers (Bevy 0.15 Picking)
          .add_observer(on_drag_start)
          .add_observer(on_drag)
          .add_observer(on_drag_end);
   }
}

// ============================================================================
// COMPONENTS
// ============================================================================

/// Main component for inventory item.
#[derive(Component)]
pub struct InventoryItem {
   pub item_id: String,
   /// List of relative coordinates (offsets) occupied by the item.
   /// (0,0) is the anchor.
   pub shape: Vec<IVec2>,
}

/// Component for Bag items that provider slots.
#[derive(Component)]
pub struct Bag {
   /// Shape of slots provided by this bag (relative to anchor).
   pub provided_slots: Vec<IVec2>,
}

/// Logical grid position.
#[derive(Component, Clone, Copy, Debug)]
pub struct GridPosition(pub IVec2);

/// Item rotation: 0=0°, 1=90°, 2=180°, 3=270°.
#[derive(Component, Clone, Copy, Debug)]
pub struct ItemRotation(pub u8);

/// Marker for items inside the "Storage" (Limbo) area.
#[derive(Component)]
pub struct InStorage;

/// Marker for UI root.
#[derive(Component)]
struct InventoryRoot;

/// Marker for the active grid area.
#[derive(Component)]
pub struct InventoryGridContainer;

/// Marker for the storage area.
#[derive(Component)]
pub struct StorageContainer;

// --- Legacy / Compatibility Components ---

#[derive(Component)]
pub struct Item;

#[derive(Component, Debug)]
pub struct ItemSize {
    pub width: i32,
    pub height: i32,
}

#[derive(Event)]
pub struct ItemSpawnedEvent(pub Entity);

// ============================================================================
// RESOURCES
// ============================================================================

#[derive(Resource, Default)]
pub struct InventoryGridState {
   pub slots: HashMap<IVec2, SlotData>,
   pub bounds: IRect,
}

#[derive(Clone, Copy, Debug)]
pub struct SlotData {
   pub bag_entity: Entity,
   pub occupier: Option<Entity>,
}

#[derive(Resource, Default)]
pub struct DragState {
   pub original_pos: Option<IVec2>,
   pub original_rotation: Option<u8>,
   pub was_in_storage: bool,
   pub attached_items: Vec<Entity>,
}

#[derive(Event)]
pub struct InventoryChangedEvent;

// ============================================================================
// CONSTANTS
// ============================================================================
const SLOT_SIZE: f32 = 64.0;
const SLOT_GAP: f32 = 2.0;
const TOTAL_CELL_SIZE: f32 = SLOT_SIZE + SLOT_GAP;
#[allow(dead_code)]
const STORAGE_OFFSET_Y: i32 = 10;

// ============================================================================
// GRID LOGIC
// ============================================================================

impl InventoryGridState {
   pub fn get_rotated_shape(shape: &Vec<IVec2>, rot: u8) -> Vec<IVec2> {
       rotate_shape(shape, rot)
   }

   pub fn rebuild(
       &mut self,
       q_bags: &Query<(Entity, &GridPosition, &ItemRotation, &Bag), Without<InStorage>>,
       q_items: &Query<(Entity, &GridPosition, &ItemRotation, &InventoryItem), (Without<Bag>, Without<InStorage>)>,
   ) {
       self.slots.clear();
       self.bounds = IRect::new(0, 0, 0, 0);

       // 1. Project Bags
       for (bag_entity, bag_pos, bag_rot, bag) in q_bags.iter() {
           let shape = rotate_shape(&bag.provided_slots, bag_rot.0);
           for offset in shape {
               let slot_pos = bag_pos.0 + offset;
               // Last bag wins if overlapping
               self.slots.insert(slot_pos, SlotData {
                   bag_entity,
                   occupier: None,
               });
               self.bounds.max = self.bounds.max.max(slot_pos);
               self.bounds.min = self.bounds.min.min(slot_pos);
           }
       }

       // 2. Place Items
       for (item_entity, item_pos, item_rot, item) in q_items.iter() {
           let shape = rotate_shape(&item.shape, item_rot.0);
           for offset in shape {
               let cell_pos = item_pos.0 + offset;

               if let Some(slot) = self.slots.get_mut(&cell_pos) {
                   if slot.occupier.is_some() {
                       warn!("Collision at {:?} by item {:?}", cell_pos, item_entity);
                   }
                   slot.occupier = Some(item_entity);
               }
           }
       }
   }

   pub fn can_place_item(
       &self,
       shape: &Vec<IVec2>,
       pos: IVec2,
       rot: u8,
       exclude_entity: Option<Entity>,
       target_is_storage: bool,
   ) -> bool {
       if target_is_storage {
           return true; // Simplified storage logic
       }

       let rotated_shape = rotate_shape(shape, rot);

       for offset in rotated_shape {
           let target_pos = pos + offset;

           match self.slots.get(&target_pos) {
               Some(slot) => {
                   if let Some(occupier) = slot.occupier {
                       if Some(occupier) != exclude_entity {
                           return false;
                       }
                   }
               },
               None => return false, // No bag underneath
           }
       }
       true
   }

   pub fn can_place_bag(
       &self,
       bag_shape: &Vec<IVec2>,
       pos: IVec2,
       rot: u8,
       exclude_bag: Option<Entity>,
   ) -> bool {
       let rotated_shape = rotate_shape(bag_shape, rot);
       for offset in rotated_shape {
           let target_pos = pos + offset;
           if let Some(slot) = self.slots.get(&target_pos) {
               if Some(slot.bag_entity) != exclude_bag {
                   return false; // Overlapping another bag
               }
           }
       }
       true
   }

   pub fn find_free_spot(&self, def: &ItemDefinition) -> Option<IVec2> {
        let min = self.bounds.min;
        let max = self.bounds.max;

        for y in min.y..=max.y {
            for x in min.x..=max.x {
                let pos = IVec2::new(x, y);
                // Try rotation 0
                if self.can_place_item(&def.shape, pos, 0, None, false) {
                    return Some(pos);
                }
            }
        }
        None
   }
}

fn rotate_shape(shape: &Vec<IVec2>, rot: u8) -> Vec<IVec2> {
   let steps = rot % 4;
   if steps == 0 { return shape.clone(); }

   shape.iter().map(|p| {
       let mut v = *p;
       for _ in 0..steps {
           v = IVec2::new(-v.y, v.x);
       }
       v
   }).collect()
}

fn calculate_bounding_box(shape: &Vec<IVec2>, rotation_step: u8) -> (i32, i32, i32, i32) {
    let rotated_shape = rotate_shape(shape, rotation_step);
    if rotated_shape.is_empty() {
        return (0, 0, 1, 1);
    }

    let mut min_x = rotated_shape[0].x;
    let mut max_x = rotated_shape[0].x;
    let mut min_y = rotated_shape[0].y;
    let mut max_y = rotated_shape[0].y;

    for p in &rotated_shape {
        if p.x < min_x { min_x = p.x; }
        if p.x > max_x { max_x = p.x; }
        if p.y < min_y { min_y = p.y; }
        if p.y > max_y { max_y = p.y; }
    }

    (min_x, min_y, max_x - min_x + 1, max_y - min_y + 1)
}


// ============================================================================
// PUBLIC HELPERS (Compatibility)
// ============================================================================

pub fn spawn_item_entity(
    commands: &mut Commands,
    container: Entity,
    def: &ItemDefinition,
    pos: IVec2,
    rotation: u8,
    _grid_state: &mut InventoryGridState,
) {
    let (_min_x, _min_y, width_slots, height_slots) = calculate_bounding_box(&def.shape, rotation);

    let width_px = width_slots as f32 * 64.0; // Fixed size based on 64px
    let height_px = height_slots as f32 * 64.0;

    let left = pos.x as f32 * 64.0;
    let top = pos.y as f32 * 64.0;

    let is_bag = matches!(def.item_type, ItemType::Bag { .. });
    let z_idx = if is_bag { ZIndex(1) } else { ZIndex(10) };
    let bg_color = if is_bag { Color::srgb(0.4, 0.2, 0.1) } else { Color::srgb(0.5, 0.5, 0.8) };

    let mut entity_cmds = commands.spawn((
        Node {
            width: Val::Px(width_px),
            height: Val::Px(height_px),
            position_type: PositionType::Absolute,
            left: Val::Px(left),
            top: Val::Px(top),
            border: UiRect::all(Val::Px(1.0)),
            ..default()
        },
        BackgroundColor(bg_color),
        InventoryItem {
            item_id: def.id.clone(),
            shape: def.shape.clone(),
        },
        GridPosition(pos),
        ItemRotation(rotation),
        z_idx,
        PickingBehavior::default(),
        // Legacy components
        Item,
        ItemSize { width: width_slots, height: height_slots },
    ));

    if is_bag {
        entity_cmds.insert(Bag { provided_slots: def.shape.clone() });
    }

    entity_cmds.with_children(|parent| {
         parent.spawn((
             Text::new(&def.name),
             TextFont { font_size: 14.0, ..default() },
             TextColor(Color::WHITE),
             Node {
                 position_type: PositionType::Absolute,
                 left: Val::Px(2.0),
                 top: Val::Px(2.0),
                 ..default()
             },
             PickingBehavior::IGNORE,
         ));
    });

    let entity = entity_cmds.id();
    commands.entity(container).add_child(entity);
}

pub struct CombatStats {
    pub attack: f32,
    pub defense: f32,
    pub speed: f32,
    pub health: f32,
}

pub fn calculate_combat_stats(
    inventory: &PersistentInventory,
    item_db: &crate::plugins::items::ItemDatabase,
) -> CombatStats {
    let mut stats = CombatStats {
        attack: 0.0,
        defense: 0.0,
        speed: 0.0,
        health: 0.0,
    };

    let mut temp_grid = InventoryGridState::default();

    // 1. Place Bags
    let mut bag_map = HashMap::new();
    for (i, saved_item) in inventory.items.iter().enumerate() {
        if let Some(def) = item_db.items.get(&saved_item.item_id) {
            if matches!(def.item_type, ItemType::Bag { .. }) {
                let entity = Entity::from_raw(i as u32); // Fake entity
                let pos = IVec2::new(saved_item.grid_x, saved_item.grid_y);
                let shape = InventoryGridState::get_rotated_shape(&def.shape, saved_item.rotation);

                bag_map.insert(entity, def.clone());

                for offset in shape {
                    let slot_pos = pos + offset;
                    temp_grid.slots.insert(slot_pos, SlotData {
                        bag_entity: entity,
                        occupier: None,
                    });
                }
            }
        }
    }

    // 2. Place Items
    let mut item_entities = Vec::new();
    for (i, saved_item) in inventory.items.iter().enumerate() {
        if let Some(def) = item_db.items.get(&saved_item.item_id) {
            if !matches!(def.item_type, ItemType::Bag { .. }) {
                let entity = Entity::from_raw(i as u32);
                let pos = IVec2::new(saved_item.grid_x, saved_item.grid_y);
                let rot = saved_item.rotation;

                item_entities.push((entity, def, pos, rot));

                let shape = InventoryGridState::get_rotated_shape(&def.shape, rot);
                for offset in shape {
                    let slot_pos = pos + offset;
                    if let Some(slot) = temp_grid.slots.get_mut(&slot_pos) {
                        slot.occupier = Some(entity);
                    }
                }
            }
        }
    }

    // 3. Stats and Synergies
    let item_lookup: HashMap<Entity, &ItemDefinition> = item_entities.iter().map(|(e, d, _, _)| (*e, *d)).collect();
    let mut bonuses: HashMap<Entity, CombatStats> = HashMap::new();

    for (entity, def, pos, rot) in &item_entities {
        for synergy in &def.synergies {
            let shape = InventoryGridState::get_rotated_shape(&vec![synergy.offset], *rot);
            if shape.is_empty() { continue; }
            let target_pos = *pos + shape[0];

            if let Some(slot) = temp_grid.slots.get(&target_pos) {
                if let Some(target_entity) = slot.occupier {
                    if let Some(target_def) = item_lookup.get(&target_entity) {
                        if synergy.target_tags.iter().any(|req| target_def.tags.contains(req)) {
                            match synergy.effect {
                                SynergyEffect::BuffSelf { stat, value } => {
                                    let b = bonuses.entry(*entity).or_insert(CombatStats { attack: 0.0, defense: 0.0, speed: 0.0, health: 0.0 });
                                    match stat {
                                        StatType::Attack => b.attack += value,
                                        StatType::Defense => b.defense += value,
                                        StatType::Speed => b.speed += value,
                                        StatType::Health => b.health += value,
                                    }
                                },
                                SynergyEffect::BuffTarget { stat, value } => {
                                    let b = bonuses.entry(target_entity).or_insert(CombatStats { attack: 0.0, defense: 0.0, speed: 0.0, health: 0.0 });
                                    match stat {
                                        StatType::Attack => b.attack += value,
                                        StatType::Defense => b.defense += value,
                                        StatType::Speed => b.speed += value,
                                        StatType::Health => b.health += value,
                                    }
                                },
                                _ => {}
                            }
                        }
                    }
                }
            }
        }
    }

    for (entity, def, _, _) in &item_entities {
        stats.attack += def.attack;
        stats.defense += def.defense;
        stats.speed += def.speed;

        if let Some(bonus) = bonuses.get(entity) {
            stats.attack += bonus.attack;
            stats.defense += bonus.defense;
            stats.speed += bonus.speed;
            stats.health += bonus.health;
        }
    }

    stats
}

// ============================================================================
// DRAG AND DROP SYSTEMS (Observers)
// ============================================================================

fn on_drag_start(
   trigger: Trigger<Pointer<DragStart>>,
   mut commands: Commands,
   q_items: Query<(Entity, &GridPosition, &ItemRotation, Option<&Bag>, Has<InStorage>), With<InventoryItem>>,
   mut drag_state: ResMut<DragState>,
   mut q_node: Query<(&mut ZIndex, &Node)>,
   grid_state: Res<InventoryGridState>,
) {
   let entity = trigger.entity();

   if let Ok((_e, grid_pos, rot, is_bag, in_storage)) = q_items.get(entity) {
       drag_state.original_pos = Some(grid_pos.0);
       drag_state.original_rotation = Some(rot.0);
       drag_state.was_in_storage = in_storage;
       drag_state.attached_items.clear();

       if is_bag.is_some() && !in_storage {
           for (_slot_pos, slot_data) in &grid_state.slots {
               if slot_data.bag_entity == entity {
                   if let Some(occupier) = slot_data.occupier {
                       if !drag_state.attached_items.contains(&occupier) {
                           drag_state.attached_items.push(occupier);
                       }
                   }
               }
           }
       }

       if let Ok((mut z_index, _)) = q_node.get_mut(entity) {
           *z_index = ZIndex(100);
       }

       commands.entity(entity).insert(PickingBehavior::IGNORE);
   }
}

fn on_drag(
   trigger: Trigger<Pointer<Drag>>,
   mut q_node: Query<&mut Node>,
) {
   let entity = trigger.entity();
   let drag_event = trigger.event();

   if let Ok(mut node) = q_node.get_mut(entity) {
       if let Val::Px(left) = node.left {
           node.left = Val::Px(left + drag_event.delta.x);
       }
       if let Val::Px(top) = node.top {
           node.top = Val::Px(top + drag_event.delta.y);
       }
   }
}

fn on_drag_end(
   trigger: Trigger<Pointer<DragEnd>>,
   mut commands: Commands,
   mut queries: ParamSet<(
       Query<(Entity, &mut GridPosition, &mut ItemRotation, &InventoryItem, &Node, Option<&Bag>, Has<InStorage>)>, // Mutable
       (
           Query<(Entity, &GridPosition, &ItemRotation, &Bag), Without<InStorage>>, // Bags Read-Only
           Query<(Entity, &GridPosition, &ItemRotation, &InventoryItem), (Without<Bag>, Without<InStorage>)> // Items Read-Only
       )
   )>,
   mut grid_state: ResMut<InventoryGridState>,
   drag_state: Res<DragState>,
   mut ev_changed: EventWriter<InventoryChangedEvent>,
) {
   let entity = trigger.entity();

   // Restore interactivity so it can be dragged again
   commands.entity(entity).insert(PickingBehavior::default());

   let mut success = false;
   let mut delta = IVec2::ZERO;

   {
       let mut q_mutable = queries.p0();
       if let Ok((_, mut grid_pos, mut rot, item_def, node, is_bag, _)) = q_mutable.get_mut(entity) {

           let current_left = if let Val::Px(v) = node.left { v } else { 0.0 };
           let current_top = if let Val::Px(v) = node.top { v } else { 0.0 };

           let is_storage_drop = current_top > 400.0; // Threshold for storage

           let target_x = (current_left / TOTAL_CELL_SIZE).round() as i32;
           let target_y = (current_top / TOTAL_CELL_SIZE).round() as i32;
           let target_pos = IVec2::new(target_x, target_y);

           let mut valid = false;

           if is_storage_drop {
               commands.entity(entity).insert(InStorage);
               valid = true;
           } else {
               commands.entity(entity).remove::<InStorage>();

               if let Some(bag) = is_bag {
                   if grid_state.can_place_bag(&bag.provided_slots, target_pos, rot.0, Some(entity)) {
                       valid = true;
                   }
               } else {
                   if grid_state.can_place_item(&item_def.shape, target_pos, rot.0, Some(entity), false) {
                       valid = true;
                   }
               }
           }

           if valid {
               if is_bag.is_some() && !is_storage_drop {
                    delta = target_pos - drag_state.original_pos.unwrap_or(target_pos);
               }

               grid_pos.0 = target_pos;
               ev_changed.send(InventoryChangedEvent);
               success = true;
           } else {
               if let Some(orig) = drag_state.original_pos {
                   grid_pos.0 = orig;
               }
               if let Some(orig_rot) = drag_state.original_rotation {
                   rot.0 = orig_rot;
               }
               if drag_state.was_in_storage {
                    commands.entity(entity).insert(InStorage);
               } else {
                    commands.entity(entity).remove::<InStorage>();
               }
           }
       }
   }

   if success && delta != IVec2::ZERO {
       let mut q_mutable = queries.p0();
       for attached_entity in &drag_state.attached_items {
            if let Ok((_, mut item_pos, _, _, _, _, _)) = q_mutable.get_mut(*attached_entity) {
                item_pos.0 += delta;
            }
       }
   }

   let (q_bags, q_items) = queries.p1();
   grid_state.rebuild(&q_bags, &q_items);
}

// ============================================================================
// VISUAL SYSTEMS
// ============================================================================

fn update_grid_visuals(
   mut q_items: Query<(Entity, &GridPosition, &mut Node, &mut ZIndex, Option<&PickingBehavior>), (With<InventoryItem>, Changed<GridPosition>)>,
) {
   for (_entity, pos, mut node, mut z_index, picking) in q_items.iter_mut() {
       if let Some(behavior) = picking {
           if *behavior == PickingBehavior::IGNORE {
               continue;
           }
       }
       node.left = Val::Px(pos.0.x as f32 * TOTAL_CELL_SIZE);
       node.top = Val::Px(pos.0.y as f32 * TOTAL_CELL_SIZE);
       *z_index = ZIndex(10);
   }
}

fn handle_keyboard_rotation(
   input: Res<ButtonInput<KeyCode>>,
   mut q_items: Query<(&mut ItemRotation, &mut Node, &PickingBehavior)>,
) {
   if input.just_pressed(KeyCode::KeyR) {
       for (mut rot, mut node, behavior) in q_items.iter_mut() {
           // Only rotate if currently being dragged (PickingBehavior::IGNORE)
           if *behavior == PickingBehavior::IGNORE {
               rot.0 = (rot.0 + 1) % 4;
               let temp = node.width;
               node.width = node.height;
               node.height = temp;
           }
       }
   }
}

// ============================================================================
// UI SETUP
// ============================================================================

fn setup_inventory_ui(mut commands: Commands) {
   commands.spawn((
       Node {
           width: Val::Percent(100.0),
           height: Val::Percent(100.0),
           justify_content: JustifyContent::FlexStart,
           align_items: AlignItems::Center,
           flex_direction: FlexDirection::Column,
           ..default()
       },
       InventoryRoot,
   )).with_children(|parent| {
       // 1. Grid Area
       parent.spawn((
           Node {
               width: Val::Px(800.0),
               height: Val::Px(400.0),
               position_type: PositionType::Relative,
               border: UiRect::all(Val::Px(2.0)),
               margin: UiRect::bottom(Val::Px(20.0)),
               ..default()
           },
           InventoryGridContainer,
           BackgroundColor(Color::srgb(0.2, 0.2, 0.2)),
       ));

       // 2. Storage Area
       parent.spawn((
            Node {
               width: Val::Px(800.0),
               height: Val::Px(200.0),
               position_type: PositionType::Relative,
               border: UiRect::all(Val::Px(2.0)),
               ..default()
           },
           StorageContainer,
           BackgroundColor(Color::srgb(0.15, 0.15, 0.25)),
       )).with_children(|p| {
            p.spawn((
               Text::new("STORAGE (LIMBO)"),
               TextFont { font_size: 20.0, ..default() },
               TextColor(Color::WHITE),
               Node { position_type: PositionType::Absolute, top: Val::Px(5.0), left: Val::Px(5.0), ..default() },
            ));
       });
   });
}

fn cleanup_inventory(mut commands: Commands, q: Query<Entity, With<InventoryRoot>>) {
   for e in q.iter() {
       commands.entity(e).despawn_recursive();
   }
}

fn debug_grid_gizmos(_gizmos: Gizmos) {}


==================================================
ФАЙЛ: src\plugins\items.rs
==================================================

use bevy::prelude::*;
use bevy::utils::HashMap;
use serde::Deserialize;

#[derive(Resource, Default)]
pub struct ItemDatabase {
    pub items: HashMap<String, ItemDefinition>,
    pub recipes: Vec<RecipeDefinition>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct RecipeDefinition {
    pub ingredients: Vec<String>, // List of item IDs required
    pub result: String, // Item ID produced
    #[serde(default)]
    pub catalysts: Vec<String>, // Item IDs that are required but not consumed
}

#[derive(Debug, Clone, Deserialize, Component, Default)]
pub struct ItemDefinition {
    pub id: String,
    pub name: String,
    pub width: u8,
    pub height: u8,
    #[serde(default)] // Allow omitting shape in JSON/RON if we generate it
    pub shape: Vec<IVec2>,
    #[allow(dead_code)]
    pub material: MaterialType,
    #[allow(dead_code)]
    pub item_type: ItemType,

    #[serde(default)]
    pub rarity: ItemRarity,

    #[serde(default)]
    pub price: u32,

    #[serde(default)]
    pub tags: Vec<ItemTag>,

    #[serde(default)]
    pub synergies: Vec<SynergyDefinition>,

    // Base Stats
    #[serde(default)]
    pub attack: f32,
    #[serde(default)]
    pub defense: f32,
    #[serde(default)]
    pub speed: f32,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize, Hash, PartialOrd, Ord)]
pub enum ItemRarity {
    Common,
    Rare,
    Epic,
    Legendary,
    Godly,
    Unique,
}

impl Default for ItemRarity {
    fn default() -> Self {
        Self::Common
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Deserialize, Hash)]
pub enum ItemTag {
    Weapon,
    Potion,
    Food,
    Magic,
    Valuable,
    // Add more as needed
}

#[derive(Debug, Clone, Deserialize)]
pub struct SynergyDefinition {
    // Relative coordinate from item pivot (0,0)
    // Note: This needs to rotate with the item
    pub offset: IVec2,
    // If the item at 'offset' has ANY of these tags, the effect triggers
    pub target_tags: Vec<ItemTag>,
    pub effect: SynergyEffect,
    #[serde(default)]
    pub visual_type: SynergyVisualType,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize, Default)]
pub enum SynergyVisualType {
    #[default]
    None,
    Star,    // Activator
    Diamond, // Target
}

#[derive(Debug, Clone, Deserialize)]
pub enum SynergyEffect {
    // Apply stat bonus to the TARGET item
    BuffTarget {
        stat: StatType,
        value: f32,
    },
    // Apply stat bonus to SELF if target is found
    BuffSelf {
        stat: StatType,
        value: f32,
    },
    // Bonus for BEING inside a specific bag type
    BagBonus {
        bag_type: BagType,
        stat: StatType,
        value: f32,
    },
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize, Hash)]
pub enum StatType {
    Attack,
    Defense,
    Speed,
    Health,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize, Default)]
#[allow(dead_code)]
pub enum MaterialType {
    #[default]
    Steel,
    Silver,
    Flesh,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize, Default)]
#[allow(dead_code)]
pub enum ItemType {
    #[default]
    Weapon,
    Consumable,
    Ammo,
    Bag { bag_type: BagType },
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize, Default)]
pub enum BagType {
    #[default]
    Default,
    Leather,
    PotionBelt,
    StaminaSack,
    FannyPack,
}

pub struct ItemsPlugin;

impl Plugin for ItemsPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<ItemDatabase>()
           .add_systems(Startup, load_items);
    }
}

fn load_items(mut item_db: ResMut<ItemDatabase>) {
    // For now, we mock the database loading.
    // In a real implementation, this would load from assets/items/*.ron

    let mut items = vec![
        ItemDefinition {
            id: "steel_sword".to_string(),
            name: "Steel Sword".to_string(),
            width: 1,
            height: 2,
            shape: vec![], // Will be populated below
            material: MaterialType::Steel,
            item_type: ItemType::Weapon,
            rarity: ItemRarity::Common,
            price: 5,
            tags: vec![ItemTag::Weapon],
            synergies: vec![],
            attack: 10.0,
            defense: 0.0,
            speed: 0.0,
        },
        ItemDefinition {
            id: "silver_dagger".to_string(),
            name: "Silver Dagger".to_string(),
            width: 1,
            height: 1,
            shape: vec![],
            material: MaterialType::Silver,
            item_type: ItemType::Weapon,
            rarity: ItemRarity::Rare,
            price: 7,
            tags: vec![ItemTag::Weapon],
            synergies: vec![],
            attack: 8.0,
            defense: 0.0,
            speed: 5.0,
        },
        ItemDefinition {
            id: "health_potion".to_string(),
            name: "Health Potion".to_string(),
            width: 1,
            height: 1,
            shape: vec![],
            material: MaterialType::Flesh,
            item_type: ItemType::Consumable,
            rarity: ItemRarity::Common,
            price: 3,
            tags: vec![ItemTag::Potion],
            synergies: vec![],
            attack: 0.0,
            defense: 0.0,
            speed: 0.0,
        },
        ItemDefinition {
            id: "whetstone".to_string(),
            name: "Whetstone".to_string(),
            width: 1,
            height: 1,
            shape: vec![],
            material: MaterialType::Steel,
            item_type: ItemType::Consumable,
            rarity: ItemRarity::Common,
            price: 4,
            tags: vec![ItemTag::Valuable],
            synergies: vec![
                SynergyDefinition {
                    offset: IVec2::new(1, 0), // Right
                    target_tags: vec![ItemTag::Weapon],
                    effect: SynergyEffect::BuffTarget { stat: StatType::Attack, value: 5.0 },
                    visual_type: SynergyVisualType::Star,
                },
                SynergyDefinition {
                    offset: IVec2::new(-1, 0), // Left
                    target_tags: vec![ItemTag::Weapon],
                    effect: SynergyEffect::BuffTarget { stat: StatType::Attack, value: 5.0 },
                    visual_type: SynergyVisualType::Star,
                },
                SynergyDefinition {
                    offset: IVec2::new(0, 1), // Top
                    target_tags: vec![ItemTag::Weapon],
                    effect: SynergyEffect::BuffTarget { stat: StatType::Attack, value: 5.0 },
                    visual_type: SynergyVisualType::Star,
                },
                SynergyDefinition {
                    offset: IVec2::new(0, -1), // Bottom
                    target_tags: vec![ItemTag::Weapon],
                    effect: SynergyEffect::BuffTarget { stat: StatType::Attack, value: 5.0 },
                    visual_type: SynergyVisualType::Star,
                }
            ],
            attack: 0.0,
            defense: 0.0,
            speed: 0.0,
        },
        // Adding more items to test rarity
        ItemDefinition {
            id: "epic_shield".to_string(),
            name: "Epic Shield".to_string(),
            width: 2,
            height: 2,
            shape: vec![],
            material: MaterialType::Steel,
            item_type: ItemType::Weapon,
            rarity: ItemRarity::Epic,
            price: 12,
            tags: vec![ItemTag::Weapon],
            synergies: vec![],
            attack: 2.0,
            defense: 20.0,
            speed: -2.0,
        },
        ItemDefinition {
            id: "legendary_bow".to_string(),
            name: "Legendary Bow".to_string(),
            width: 1,
            height: 3,
            shape: vec![],
            material: MaterialType::Flesh,
            item_type: ItemType::Weapon,
            rarity: ItemRarity::Legendary,
            price: 25,
            tags: vec![ItemTag::Weapon],
            synergies: vec![],
            attack: 15.0,
            defense: 0.0,
            speed: 10.0,
        },
        ItemDefinition {
             id: "unique_charm".to_string(),
             name: "Unique Charm".to_string(),
             width: 1,
             height: 1,
             shape: vec![],
             material: MaterialType::Silver,
             item_type: ItemType::Consumable,
             rarity: ItemRarity::Unique,
             price: 50,
             tags: vec![ItemTag::Valuable],
             synergies: vec![],
             attack: 0.0,
             defense: 0.0,
             speed: 0.0,
        },
        // Bags
        ItemDefinition {
            id: "starter_bag".to_string(),
            name: "Starter Bag".to_string(),
            width: 3,
            height: 3,
            shape: vec![],
            material: MaterialType::Flesh, // Leather
            item_type: ItemType::Bag { bag_type: BagType::Default },
            rarity: ItemRarity::Common, // Not in shop typically
            price: 0,
            tags: vec![],
            synergies: vec![],
            attack: 0.0,
            defense: 0.0,
            speed: 0.0,
        },
        ItemDefinition {
            id: "leather_bag".to_string(),
            name: "Leather Bag".to_string(),
            width: 2,
            height: 2,
            shape: vec![],
            material: MaterialType::Flesh,
            item_type: ItemType::Bag { bag_type: BagType::Leather },
            rarity: ItemRarity::Common,
            price: 4,
            tags: vec![],
            synergies: vec![],
            attack: 0.0,
            defense: 0.0,
            speed: 0.0,
        },
        ItemDefinition {
            id: "fanny_pack".to_string(),
            name: "Fanny Pack".to_string(),
            width: 2,
            height: 1,
            shape: vec![],
            material: MaterialType::Flesh,
            item_type: ItemType::Bag { bag_type: BagType::FannyPack },
            rarity: ItemRarity::Rare,
            price: 6,
            tags: vec![],
            synergies: vec![
                 // Example synergy: Speed up items inside? For now placeholder.
            ],
            attack: 0.0,
            defense: 0.0,
            speed: 0.0,
        },
        ItemDefinition {
            id: "potion_belt".to_string(),
            name: "Potion Belt".to_string(),
            width: 3,
            height: 1,
            shape: vec![],
            material: MaterialType::Flesh,
            item_type: ItemType::Bag { bag_type: BagType::PotionBelt },
            rarity: ItemRarity::Epic,
            price: 8,
            tags: vec![],
            synergies: vec![],
            attack: 0.0,
            defense: 0.0,
            speed: 0.0,
        },
        ItemDefinition {
            id: "stamina_sack".to_string(),
            name: "Stamina Sack".to_string(),
            width: 1,
            height: 1,
            shape: vec![],
            material: MaterialType::Flesh,
            item_type: ItemType::Bag { bag_type: BagType::StaminaSack },
            rarity: ItemRarity::Rare,
            price: 5,
            tags: vec![],
            synergies: vec![],
            attack: 0.0,
            defense: 0.0,
            speed: 0.0,
        },
    ];

    // Auto-generate rectangular shapes if empty
    for item in items.iter_mut() {
        if item.shape.is_empty() {
            for y in 0..item.height {
                for x in 0..item.width {
                    item.shape.push(IVec2::new(x as i32, y as i32));
                }
            }
        }
    }

    for item in items {
        item_db.items.insert(item.id.clone(), item);
    }

    info!("ItemDatabase loaded with {} items.", item_db.items.len());

    // Mock Recipes
    item_db.recipes = vec![
        RecipeDefinition {
            ingredients: vec!["steel_sword".to_string(), "whetstone".to_string()],
            result: "hero_sword".to_string(), // Need to define this item if we want it to work fully
            catalysts: vec![],
        },
        RecipeDefinition {
            ingredients: vec!["health_potion".to_string(), "health_potion".to_string()],
            result: "strong_health_potion".to_string(),
            catalysts: vec![],
        }
    ];
}


==================================================
ФАЙЛ: src\plugins\metagame.rs
==================================================

use bevy::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Resource, Debug, Serialize, Deserialize, Clone)]
pub struct SaveData {
    pub player_stats: PlayerStats,
    pub global_time: GlobalTime,
    pub inventory: Vec<SavedItem>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct SavedItem {
    pub item_id: String,
    pub grid_x: i32,
    pub grid_y: i32,
    #[serde(default)]
    pub rotation: u8,
}

#[derive(Resource, Debug, Serialize, Deserialize, Clone)]
pub struct PlayerStats {
    pub thalers: u32,
    pub reputation: u32,
    pub infection: u32,
}

impl Default for PlayerStats {
    fn default() -> Self {
        Self {
            thalers: 100,
            reputation: 50,
            infection: 0,
        }
    }
}

#[derive(Resource, Debug, Serialize, Deserialize, Clone)]
pub struct GlobalTime {
    pub day: u32,
    pub hour: u32, // 0-24
}

impl Default for GlobalTime {
    fn default() -> Self {
        Self {
            day: 1,
            hour: 6, // Starts at 6:00 AM
        }
    }
}

// Plugin
use crate::plugins::core::{GameState, DaySubState};
use crate::plugins::inventory::{InventoryGridState, GridPosition, Item, ItemRotation, InventoryItem, spawn_item_entity, InventoryGridContainer};
use crate::plugins::items::{ItemDatabase, ItemType};
use std::fs::File;
use std::io::{Write, Read};

pub struct MetagamePlugin;

#[derive(Resource, Default, Debug)]
pub struct PendingItems(pub Vec<String>);

/// Holds inventory state between Evening phases (e.g. during Combat)
#[derive(Resource, Debug, Clone)]
pub struct PersistentInventory {
    pub items: Vec<SavedItem>,
}

impl Default for PersistentInventory {
    fn default() -> Self {
        Self {
            items: vec![
                // Starter Bag at center-ish
                SavedItem {
                    item_id: "starter_bag".to_string(),
                    grid_x: 2,
                    grid_y: 2,
                    rotation: 0,
                }
            ],
        }
    }
}

#[derive(Component)]
struct CityUiRoot;

#[derive(Component)]
struct CityButton(pub &'static str);

impl Plugin for MetagamePlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<PlayerStats>()
           .init_resource::<GlobalTime>()
           .init_resource::<PendingItems>()
           .init_resource::<PersistentInventory>()
           .add_systems(OnEnter(DaySubState::Idle), day_start_logic)
           .add_systems(OnEnter(GameState::DayPhase), spawn_city_ui)
           .add_systems(OnExit(GameState::DayPhase), cleanup_city_ui)
           .add_systems(Update, handle_city_buttons.run_if(in_state(GameState::DayPhase)))
           .add_systems(Update, (save_system, load_system_debug, debug_scene_transition)); // Add keyboard triggers for now
    }
}

fn spawn_city_ui(mut commands: Commands) {
    commands.spawn((
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(100.0),
            display: Display::Flex,
            justify_content: JustifyContent::Center,
            align_items: AlignItems::Center,
            flex_direction: FlexDirection::Column,
            row_gap: Val::Px(20.0),
            ..default()
        },
        BackgroundColor(Color::srgb(0.1, 0.1, 0.15)),
        CityUiRoot,
    ))
    .with_children(|parent| {
        parent.spawn((
            Text::new("City Phase\nExplore locations to find items"),
            TextFont { font_size: 30.0, ..default() },
            TextColor(Color::WHITE),
            Node { margin: UiRect::bottom(Val::Px(20.0)), ..default() },
        ));

        let buttons = [
            ("Visit Market (Sword)", "steel_sword"),
            ("Visit Slums (Dagger)", "silver_dagger"),
            ("Go to Inventory", "NEXT_PHASE"),
        ];

        for (label, action) in buttons {
            parent.spawn((
                Button,
                Node {
                    width: Val::Px(200.0),
                    height: Val::Px(50.0),
                    border: UiRect::all(Val::Px(2.0)),
                    justify_content: JustifyContent::Center,
                    align_items: AlignItems::Center,
                    ..default()
                },
                BorderColor(Color::BLACK),
                BackgroundColor(Color::srgb(0.3, 0.3, 0.4)),
                CityButton(action),
            ))
            .with_children(|p| {
                p.spawn((
                    Text::new(label),
                    TextFont { font_size: 20.0, ..default() },
                    TextColor(Color::WHITE),
                ));
            });
        }
    });
}

fn cleanup_city_ui(mut commands: Commands, q_root: Query<Entity, With<CityUiRoot>>) {
    for e in q_root.iter() {
        commands.entity(e).despawn_recursive();
    }
}

fn handle_city_buttons(
    // Removed unused mut commands
    mut q_buttons: Query<(&Interaction, &CityButton, &mut BackgroundColor), (Changed<Interaction>, With<Button>)>,
    mut pending_items: ResMut<PendingItems>,
    mut next_state: ResMut<NextState<GameState>>,
) {
    for (interaction, action, mut bg_color) in q_buttons.iter_mut() {
        match *interaction {
            Interaction::Pressed => {
                *bg_color = BackgroundColor(Color::srgb(0.2, 0.2, 0.3));
                if action.0 == "NEXT_PHASE" {
                    next_state.set(GameState::EveningPhase);
                } else {
                    pending_items.0.push(action.0.to_string());
                    info!("Found item: {}", action.0);
                }
            },
            Interaction::Hovered => {
                *bg_color = BackgroundColor(Color::srgb(0.4, 0.4, 0.5));
            },
            Interaction::None => {
                *bg_color = BackgroundColor(Color::srgb(0.3, 0.3, 0.4));
            },
        }
    }
}

fn debug_scene_transition(
    input: Res<ButtonInput<KeyCode>>,
    mut next_state: ResMut<NextState<GameState>>,
    current_state: Res<State<GameState>>,
) {
    if input.just_pressed(KeyCode::KeyT) {
        match current_state.get() {
            GameState::DayPhase => {
                info!("Transitioning to EveningPhase");
                next_state.set(GameState::EveningPhase);
            },
            GameState::EveningPhase => {
                info!("Transitioning to NightPhase");
                next_state.set(GameState::NightPhase);
            },
            GameState::NightPhase => {
                info!("Transitioning to DayPhase");
                next_state.set(GameState::DayPhase);
            },
            _ => {
                info!("Transitioning to DayPhase (default)");
                next_state.set(GameState::DayPhase);
            }
        }
    }
}

fn day_start_logic() {
    println!("Day Phase Started: Morning has broken.");
}

// Serialization Helpers

pub fn create_save_data(
    player_stats: &PlayerStats,
    global_time: &GlobalTime,
    q_items: &Query<(&InventoryItem, &GridPosition, &ItemRotation), With<Item>>,
) -> SaveData {
    let mut saved_items = Vec::new();
    for (item, pos, rot) in q_items.iter() {
        saved_items.push(SavedItem {
            item_id: item.item_id.clone(),
            grid_x: pos.0.x,
            grid_y: pos.0.y,
            rotation: rot.0,
        });
    }

    SaveData {
        player_stats: player_stats.clone(),
        global_time: global_time.clone(),
        inventory: saved_items,
    }
}

fn save_system(
    input: Res<ButtonInput<KeyCode>>,
    player_stats: Res<PlayerStats>,
    global_time: Res<GlobalTime>,
    q_items: Query<(&InventoryItem, &GridPosition, &ItemRotation), With<Item>>,
) {
    if input.just_pressed(KeyCode::F5) {
        let save_data = create_save_data(&player_stats, &global_time, &q_items);

        match serde_json::to_string_pretty(&save_data) {
            Ok(json) => {
                if let Ok(mut file) = File::create("savegame.json") {
                    if let Err(e) = file.write_all(json.as_bytes()) {
                        error!("Failed to write save file: {}", e);
                    } else {
                        info!("Game saved successfully to savegame.json");
                    }
                } else {
                    error!("Failed to create save file");
                }
            },
            Err(e) => error!("Failed to serialize save data: {}", e),
        }
    }
}

fn load_system_debug(
    input: Res<ButtonInput<KeyCode>>,
    mut commands: Commands,
    mut player_stats: ResMut<PlayerStats>,
    mut global_time: ResMut<GlobalTime>,
    mut grid_state: ResMut<InventoryGridState>,
    item_db: Res<ItemDatabase>,
    q_items: Query<Entity, With<Item>>,
    q_container: Query<Entity, With<InventoryGridContainer>>,
) {
    if input.just_pressed(KeyCode::F9) {
        if let Ok(mut file) = File::open("savegame.json") {
            let mut json = String::new();
            if file.read_to_string(&mut json).is_ok() {
                match serde_json::from_str::<SaveData>(&json) {
                    Ok(data) => {
                        // Apply loaded state
                        *player_stats = data.player_stats;
                        *global_time = data.global_time;

                        // Clear current inventory
                        for entity in q_items.iter() {
                            commands.entity(entity).despawn_recursive();
                        }

                        // Clear grid slots manually or via rebuild?
                        // Grid slots are derived from bags.
                        // When we clear items (including bags), we should clear slots too.
                        grid_state.slots.clear();

                        // Respawn items
                        if let Ok(container) = q_container.get_single() {
                            // Pass 1: Bags first to establish grid
                             for saved_item in &data.inventory {
                                if let Some(def) = item_db.items.get(&saved_item.item_id) {
                                    if matches!(def.item_type, ItemType::Bag { .. }) {
                                        spawn_item_entity(
                                             &mut commands,
                                             container,
                                             def,
                                             IVec2::new(saved_item.grid_x, saved_item.grid_y),
                                             saved_item.rotation,
                                             &mut grid_state
                                        );
                                    }
                                }
                            }

                            // Pass 2: Items
                            for saved_item in &data.inventory {
                                if let Some(def) = item_db.items.get(&saved_item.item_id) {
                                     if !matches!(def.item_type, ItemType::Bag { .. }) {
                                        spawn_item_entity(
                                             &mut commands,
                                             container,
                                             def,
                                             IVec2::new(saved_item.grid_x, saved_item.grid_y),
                                             saved_item.rotation,
                                             &mut grid_state
                                        );
                                     }
                                }
                            }
                        }

                        info!("Game loaded successfully.");
                    },
                    Err(e) => error!("Failed to deserialize save data: {}", e),
                }
            }
        } else {
            warn!("No save file found.");
        }
    }
}


==================================================
ФАЙЛ: src\plugins\mod.rs
==================================================

pub mod core;
pub mod inventory;
pub mod items;
pub mod combat;
pub mod metagame;
pub mod mutation;
pub mod ui;
pub mod shop;
pub mod visualization;


==================================================
ФАЙЛ: src\plugins\mutation.rs
==================================================

use bevy::prelude::*;
use crate::plugins::inventory::{InventoryGridState, Item, ItemSize, GridPosition};
use rand::Rng;

pub fn mutation_system(
    mut q_items: Query<(Entity, &mut ItemSize, &GridPosition), With<Item>>,
    mut grid_state: ResMut<InventoryGridState>,
    // In a real implementation, we'd check infection level here
    // infection: Res<GlobalInfection>,
) {
    // This system should run ONCE per Evening->Night transition.
    // For now, we'll assume it's called by a schedule or state change trigger.

    let mut rng = rand::thread_rng();

    // GDD: P_mut = Base + Infection * 0.5. Let's assume 10% base chance for verification.
    let mutation_chance = 0.10;

    for (entity, mut size, pos) in q_items.iter_mut() {
        if rng.gen_bool(mutation_chance) {
            info!("Item {:?} is mutating!", entity);

            // Mutation: Grow in size (e.g., width + 1)
            // We need to check if the new size fits.
            // But we are using shapes now.
            // For now, assume growth extends the shape to the right by 1 column for all rows in current shape?
            // Or just check if there is a slot to the right of the current bounding box?
            // "Stage 1" just wants grid logic. The mutation logic is legacy/extra.
            // I'll make a best effort to keep it working with the new system.

            // Check if (x + width, y) is free for all y in 0..height
            // We'll construct a shape representing the new column.
            let mut extension_shape = Vec::new();
            for dy in 0..size.height {
                 extension_shape.push(IVec2::new(size.width, dy));
            }

            // Check if valid
            if grid_state.can_place_item(&extension_shape, IVec2::new(pos.0.x, pos.0.y), 0, Some(entity), false) {
                 // Update Grid State
                 for offset in &extension_shape {
                     let new_cell_pos = IVec2::new(pos.0.x, pos.0.y) + *offset;
                     if let Some(slot) = grid_state.slots.get_mut(&new_cell_pos) {
                         slot.occupier = Some(entity);
                     }
                 }

                 // Update Component
                 size.width += 1;
                 // NOTE: Real implementation should update ItemDefinition.shape too if we want it to persist properly
                 // But ItemDefinition is shared. We'd need a dynamic ItemShape component.
                 // For now, this is enough to satisfy the compiler.
                 info!("Item grew to {:?}", *size);
            } else {
                 info!("Item tried to mutate but had no space.");
            }
        }
    }
}


==================================================
ФАЙЛ: src\plugins\shop.rs
==================================================

use bevy::prelude::*;
use rand::Rng;
use crate::plugins::items::{ItemDatabase, ItemDefinition, ItemRarity};
use crate::plugins::metagame::{PlayerStats, GlobalTime};
use crate::plugins::inventory::{InventoryGridState, spawn_item_entity, InventoryGridContainer, InventoryItem, GridPosition, ItemRotation};
use crate::plugins::core::GameState;

pub struct ShopPlugin;

impl Plugin for ShopPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<ShopState>()
           .add_systems(OnEnter(GameState::EveningPhase), on_enter_shop)
           .add_systems(OnExit(GameState::EveningPhase), cleanup_shop_ui)
           .add_systems(Update, (
               reroll_button_system,
               buy_item_system,
               lock_item_system,
               update_shop_ui_system
           ).run_if(in_state(GameState::EveningPhase)));
    }
}

#[derive(Debug, Clone)]
pub struct ShopItem {
    pub item_id: String,
    pub price: u32,
    pub is_locked: bool,
    pub is_discounted: bool,
    pub is_sold: bool,
}

#[derive(Resource, Default)]
pub struct ShopState {
    pub items: Vec<ShopItem>, // Fixed size of 5
    pub reroll_cost: u32,
    pub reroll_count: u32,
}

#[derive(Component)]
struct ShopUiRoot;

#[derive(Component)]
struct RerollButton;

#[derive(Component)]
struct ShopSlot(#[allow(dead_code)] usize);

#[derive(Component)]
struct LockButton(usize);

#[derive(Component)]
struct BuyButton(usize);

fn on_enter_shop(
    mut shop_state: ResMut<ShopState>,
    item_db: Res<ItemDatabase>,
    global_time: Res<GlobalTime>,
    mut commands: Commands,
) {
    shop_state.reroll_cost = 1;
    shop_state.reroll_count = 0;

    let round = global_time.day;

    let mut locked_items = Vec::new();
    if !shop_state.items.is_empty() {
        for item in &shop_state.items {
            if item.is_locked && !item.is_sold {
                locked_items.push(item.clone());
            }
        }
    }

    shop_state.items.clear();

    for item in locked_items {
        shop_state.items.push(item);
    }

    let needed = 5 - shop_state.items.len();
    if needed > 0 {
         let generated = generate_shop_items(&item_db, round, needed, true);
         shop_state.items.extend(generated);
    }

    spawn_shop_ui(&mut commands, &shop_state, &item_db);
}

pub fn generate_shop_items(
    item_db: &ItemDatabase,
    round: u32,
    count: usize,
    is_start_of_round: bool
) -> Vec<ShopItem> {
    let mut rng = rand::thread_rng();
    let mut results = Vec::new();

    for _ in 0..count {
        let rarity = roll_rarity(round, &mut rng, is_start_of_round);

        let candidates: Vec<&ItemDefinition> = item_db.items.values()
            .filter(|i| i.rarity == rarity)
            .collect();

        if let Some(choice) = pick_random(&candidates, &mut rng) {
             let is_discounted = rng.gen_bool(0.10);
             let mut price = choice.price;
             if is_discounted {
                 price = (price as f32 * 0.5).ceil() as u32;
             }

             results.push(ShopItem {
                 item_id: choice.id.clone(),
                 price,
                 is_locked: false,
                 is_discounted,
                 is_sold: false,
             });
        } else {
             if let Some(fallback) = item_db.items.values().filter(|i| i.rarity == ItemRarity::Common).next() {
                  results.push(ShopItem {
                     item_id: fallback.id.clone(),
                     price: fallback.price,
                     is_locked: false,
                     is_discounted: false,
                     is_sold: false,
                 });
             }
        }
    }

    results
}

pub fn roll_rarity(round: u32, rng: &mut impl Rng, is_start_of_round: bool) -> ItemRarity {
    if is_start_of_round && round >= 4 {
        if rng.gen_bool(0.02) {
            return ItemRarity::Unique;
        }
    }

    let (common, rare, epic, legendary, godly) = if round <= 3 {
        (80, 20, 0, 0, 0)
    } else if round <= 7 {
        (60, 30, 10, 0, 0)
    } else if round <= 10 {
        (40, 30, 25, 5, 0)
    } else {
        (20, 30, 30, 15, 5)
    };

    let total = common + rare + epic + legendary + godly;
    let roll = rng.gen_range(0..total);

    if roll < common { ItemRarity::Common }
    else if roll < common + rare { ItemRarity::Rare }
    else if roll < common + rare + epic { ItemRarity::Epic }
    else if roll < common + rare + epic + legendary { ItemRarity::Legendary }
    else { ItemRarity::Godly }
}

pub fn pick_random<'a, T>(list: &'a Vec<T>, rng: &mut impl Rng) -> Option<&'a T> {
    if list.is_empty() { return None; }
    let idx = rng.gen_range(0..list.len());
    Some(&list[idx])
}

// UI Systems

fn spawn_shop_ui(
    commands: &mut Commands,
    shop_state: &ShopState,
    item_db: &ItemDatabase,
) {
    commands.spawn((
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(30.0),
            position_type: PositionType::Absolute,
            top: Val::Px(0.0),
            left: Val::Px(0.0),
            display: Display::Flex,
            flex_direction: FlexDirection::Row,
            justify_content: JustifyContent::SpaceEvenly,
            align_items: AlignItems::Center,
            padding: UiRect::all(Val::Px(10.0)),
            ..default()
        },
        BackgroundColor(Color::srgb(0.2, 0.15, 0.1)),
        ShopUiRoot,
    ))
    .with_children(|parent| {
        // Reroll Button / Info
        parent.spawn((
            Node {
                flex_direction: FlexDirection::Column,
                align_items: AlignItems::Center,
                ..default()
            },
        )).with_children(|p| {
             p.spawn((
                Button,
                Node {
                    width: Val::Px(80.0),
                    height: Val::Px(50.0),
                    justify_content: JustifyContent::Center,
                    align_items: AlignItems::Center,
                    ..default()
                },
                BackgroundColor(Color::srgb(0.6, 0.4, 0.2)),
                RerollButton,
            )).with_children(|btn| {
                btn.spawn((
                    Text::new(format!("Reroll\n{}g", shop_state.reroll_cost)),
                    TextFont { font_size: 16.0, ..default() },
                    TextColor(Color::WHITE),
                ));
            });
        });

        // Shop Slots
        for (i, item) in shop_state.items.iter().enumerate() {
            if let Some(def) = item_db.items.get(&item.item_id) {
                let bg_color = if item.is_sold {
                    Color::srgba(0.1, 0.1, 0.1, 0.5)
                } else if item.is_locked {
                    Color::srgb(0.3, 0.3, 0.5) // Blueish for locked
                } else {
                    Color::srgb(0.4, 0.3, 0.2)
                };

                parent.spawn((
                    Node {
                        width: Val::Px(120.0), // Wider to fit visual
                        height: Val::Px(160.0),
                        flex_direction: FlexDirection::Column,
                        align_items: AlignItems::Center,
                        margin: UiRect::all(Val::Px(5.0)),
                        border: UiRect::all(Val::Px(2.0)),
                        ..default()
                    },
                    BackgroundColor(bg_color),
                    BorderColor(if item.is_discounted { Color::srgb(1.0, 0.8, 0.0) } else { Color::BLACK }),
                    ShopSlot(i),
                )).with_children(|slot| {
                    // Item Name
                    slot.spawn((
                        Text::new(&def.name),
                        TextFont { font_size: 14.0, ..default() },
                        TextColor(Color::WHITE),
                    ));

                    // Visual Item Preview
                    // We spawn a "preview" node. We might need to scale it down if it's huge?
                    // For now, let's just create a container for it.
                    slot.spawn(Node {
                        width: Val::Px(80.0),
                        height: Val::Px(80.0), // Fixed preview box
                        align_items: AlignItems::Center,
                        justify_content: JustifyContent::Center,
                        overflow: Overflow::clip(), // Clip if too big
                        ..default()
                    }).with_children(|preview| {
                        // Spawn the visual representation inside the preview
                        // We use (0,0) as relative pos
                        // Note: spawn_visual_item spawns a child.
                         // We need to pass commands to it.
                         // But we are in a closure.
                         // We can't easily call helper with commands.
                         // We'll create a manual visual item here or use a command queue.
                         // Or just manual for now since we are in `with_children`.

                         let w = def.width as f32 * 32.0; // Half size for preview?
                         let h = def.height as f32 * 32.0;

                         preview.spawn((
                               Node {
                                   width: Val::Px(w),
                                   height: Val::Px(h),
                                   ..default()
                               },
                               BackgroundColor(Color::srgb(0.5, 0.5, 0.5)),
                               // We don't add InventoryItem component here to avoid it being interactable in drag system?
                               // Or we do but ignore it?
                               // The instruction says "items in shop are same InventoryItem".
                               // So we add it.
                               InventoryItem {
                                   item_id: def.id.clone(),
                                   shape: def.shape.clone()
                               },
                               GridPosition(IVec2::ZERO),
                               ItemRotation(0),
                               // PickingBehavior::IGNORE so we can't drag from shop?
                               // Or we want to drag from shop to buy?
                               // Instruction says "Shop not as separate scene... items in shop are same InventoryItem...".
                               // But typically shop buying is click-to-buy or drag-to-buy.
                               // Current logic is "Buy Button". So let's ignore drag for now.
                               PickingBehavior::IGNORE,
                         ));
                    });


                    // Price
                    slot.spawn((
                        Text::new(format!("{}g", item.price)),
                        TextFont { font_size: 16.0, ..default() },
                        TextColor(if item.is_discounted { Color::srgb(0.0, 1.0, 0.0) } else { Color::WHITE }),
                    ));

                     // Buy Button (if not sold)
                     if !item.is_sold {
                         slot.spawn((
                            Button,
                            Node {
                                width: Val::Px(80.0),
                                height: Val::Px(30.0),
                                margin: UiRect::top(Val::Px(5.0)),
                                justify_content: JustifyContent::Center,
                                align_items: AlignItems::Center,
                                ..default()
                            },
                            BackgroundColor(Color::srgb(0.2, 0.6, 0.2)),
                            BuyButton(i),
                        )).with_children(|btn| {
                            btn.spawn((
                                Text::new("Buy"),
                                TextFont { font_size: 14.0, ..default() },
                                TextColor(Color::WHITE),
                            ));
                        });

                         // Lock Button
                         slot.spawn((
                            Button,
                            Node {
                                width: Val::Px(80.0),
                                height: Val::Px(20.0),
                                margin: UiRect::top(Val::Px(5.0)),
                                justify_content: JustifyContent::Center,
                                align_items: AlignItems::Center,
                                ..default()
                            },
                            BackgroundColor(if item.is_locked { Color::srgb(0.3, 0.3, 0.8) } else { Color::srgb(0.4, 0.4, 0.4) }),
                            LockButton(i),
                        )).with_children(|btn| {
                            btn.spawn((
                                Text::new(if item.is_locked { "Unlock" } else { "Lock" }),
                                TextFont { font_size: 12.0, ..default() },
                                TextColor(Color::WHITE),
                            ));
                        });
                     } else {
                         slot.spawn((
                             Text::new("SOLD"),
                             TextFont { font_size: 20.0, ..default() },
                             TextColor(Color::srgb(0.5, 0.5, 0.5)),
                         ));
                     }
                });
            }
        }
    });
}

fn cleanup_shop_ui(mut commands: Commands, q_root: Query<Entity, With<ShopUiRoot>>) {
    for e in q_root.iter() {
        commands.entity(e).despawn_recursive();
    }
}

// Interactivity Systems

fn reroll_button_system(
    mut interaction_query: Query<
        (&Interaction, &mut BackgroundColor),
        (Changed<Interaction>, With<RerollButton>),
    >,
    mut shop_state: ResMut<ShopState>,
    mut player_stats: ResMut<PlayerStats>,
    global_time: Res<GlobalTime>,
    item_db: Res<ItemDatabase>,
    mut commands: Commands,
    q_root: Query<Entity, With<ShopUiRoot>>,
) {
    for (interaction, mut color) in &mut interaction_query {
        match *interaction {
            Interaction::Pressed => {
                *color = BackgroundColor(Color::srgb(0.35, 0.75, 0.35));

                if player_stats.thalers >= shop_state.reroll_cost {
                    player_stats.thalers -= shop_state.reroll_cost;

                    shop_state.reroll_count += 1;
                    if shop_state.reroll_count >= 4 {
                        shop_state.reroll_cost = 2;
                    } else {
                         shop_state.reroll_cost = 1;
                    }

                    let mut new_items = Vec::new();

                     for item in &shop_state.items {
                        if item.is_locked && !item.is_sold {
                            new_items.push(item.clone());
                        }
                    }

                    let needed = 5 - new_items.len();
                    if needed > 0 {
                        let generated = generate_shop_items(&item_db, global_time.day, needed, false);
                        new_items.extend(generated);
                    }

                    shop_state.items = new_items;

                    if let Ok(root) = q_root.get_single() {
                        commands.entity(root).despawn_recursive();
                        // Re-spawning UI in the same frame after despawn might be tricky with ownership of commands.
                        // However, we can just call it.
                        // But wait, spawn_shop_ui now consumes commands.
                        // We can't do that inside a loop or system easily if we needed commands elsewhere.
                        // But here we are at end of system.
                        // Actually, commands is passed into system.
                        // spawn_shop_ui(commands, ...) consumes it.
                        // But we might need commands for other things or if this loop runs multiple times (unlikely for buttons).
                        // It's better to NOT consume commands in spawn_shop_ui if we can avoid it.
                        // But I changed it to consume because of lifetime issues in recursive calls?
                        // No, the previous error was closure borrow.

                        // Let's revert spawn_shop_ui to take &mut Commands and fix the closure issue by NOT using commands inside the closure if possible,
                        // or by re-architecting the closure usage.
                        // The issue was: commands.spawn(...).with_children(|parent| { ... commands.entity(...) ... })
                        // Inside with_children, we use `parent` (ChildBuilder) to spawn children.
                        // But I was using `commands.entity(slot_entity)` inside the outer loop but inside `parent` loop?

                        // Let's look at the structure in `shop.rs`:
                        /*
                        commands.spawn(...).with_children(|parent| {
                            ...
                            for item in items {
                                let slot_entity = parent.spawn(...).id();
                                commands.entity(slot_entity).with_children(...) // ERROR: borrowing commands while commands is borrowed by parent.spawn
                            }
                        })
                        */
                        // Solution: Use `parent` to spawn slot, and `with_children` on the slot command builder directly!

                        // I will revert the signature change and fix the logic.
                         spawn_shop_ui(&mut commands, &shop_state, &item_db);
                    }
                }
            }
            Interaction::Hovered => {
                *color = BackgroundColor(Color::srgb(0.7, 0.5, 0.3));
            }
            Interaction::None => {
                *color = BackgroundColor(Color::srgb(0.6, 0.4, 0.2));
            }
        }
    }
}

fn lock_item_system(
    mut interaction_query: Query<
        (&Interaction, &LockButton),
        (Changed<Interaction>, With<Button>),
    >,
    mut shop_state: ResMut<ShopState>,
    item_db: Res<ItemDatabase>,
    mut commands: Commands,
    q_root: Query<Entity, With<ShopUiRoot>>,
) {
     for (interaction, lock_btn) in &mut interaction_query {
        if *interaction == Interaction::Pressed {
            let index = lock_btn.0;
            if index < shop_state.items.len() {
                shop_state.items[index].is_locked = !shop_state.items[index].is_locked;

                if let Ok(root) = q_root.get_single() {
                    commands.entity(root).despawn_recursive();
                    spawn_shop_ui(&mut commands, &shop_state, &item_db);
                }
            }
        }
    }
}

fn buy_item_system(
    mut interaction_query: Query<
        (&Interaction, &BuyButton),
        (Changed<Interaction>, With<Button>),
    >,
    mut shop_state: ResMut<ShopState>,
    mut player_stats: ResMut<PlayerStats>,
    mut grid_state: ResMut<InventoryGridState>,
    item_db: Res<ItemDatabase>,
    mut commands: Commands,
    q_root: Query<Entity, With<ShopUiRoot>>,
    q_container: Query<Entity, With<InventoryGridContainer>>,
    _pending_items: ResMut<crate::plugins::metagame::PendingItems>,
) {
    for (interaction, buy_btn) in &mut interaction_query {
        if *interaction == Interaction::Pressed {
            let index = buy_btn.0;
            if index < shop_state.items.len() {
                let item = &mut shop_state.items[index];
                if !item.is_sold && player_stats.thalers >= item.price {
                     if let Some(def) = item_db.items.get(&item.item_id) {
                         if let Some(pos) = grid_state.find_free_spot(def) {
                             player_stats.thalers -= item.price;
                             item.is_sold = true;

                             if let Ok(container) = q_container.get_single() {
                                 spawn_item_entity(
                                     &mut commands,
                                     container,
                                     def,
                                     pos,
                                     0,
                                     &mut grid_state
                                 );
                             }

                            if let Ok(root) = q_root.get_single() {
                                commands.entity(root).despawn_recursive();
                                spawn_shop_ui(&mut commands, &shop_state, &item_db);
                            }
                         } else {
                             info!("No space for item!");
                         }
                     }
                }
            }
        }
    }
}

fn update_shop_ui_system() {
}


==================================================
ФАЙЛ: src\plugins\ui.rs
==================================================

use bevy::prelude::*;
use crate::plugins::metagame::{PlayerStats, GlobalTime};
use crate::plugins::core::GameState;

pub struct UiPlugin;

impl Plugin for UiPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Startup, spawn_hud)
           .add_systems(Update, update_hud);
    }
}

// Marker components for UI updates
#[derive(Component)]
struct PhaseText;

#[derive(Component)]
struct StatsText;

fn spawn_hud(mut commands: Commands) {
    // Root UI Node (Overlay)
    commands.spawn((
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(100.0),
            position_type: PositionType::Absolute,
            justify_content: JustifyContent::SpaceBetween,
            flex_direction: FlexDirection::Column,
            // pointer_events removed, using PickingBehavior if needed or default.
            // Bevy 0.15 defaults to passing through if no interaction components?
            // Actually, Node blocks clicks by default in picking.
            // We need PickingBehavior::Ignore.
            ..default()
        },
        PickingBehavior::IGNORE,
        ZIndex(200), // Above everything
    ))
    .with_children(|parent| {
        // Top Bar (Stats & Info)
        parent.spawn((
            Node {
                width: Val::Percent(100.0),
                height: Val::Px(40.0),
                align_items: AlignItems::Center,
                padding: UiRect::horizontal(Val::Px(10.0)),
                justify_content: JustifyContent::SpaceBetween,
                ..default()
            },
            BackgroundColor(Color::srgb(0.0, 0.0, 0.0).with_alpha(0.8)),
        ))
        .with_children(|top_bar| {
            // Phase Display
            top_bar.spawn((
                Text::new("Phase: Init"),
                TextFont {
                    font_size: 20.0,
                    ..default()
                },
                TextColor(Color::WHITE),
                PhaseText,
            ));

            // Stats Display
            top_bar.spawn((
                Text::new("Thalers: 0 | Rep: 0 | Inf: 0"),
                TextFont {
                    font_size: 20.0,
                    ..default()
                },
                TextColor(Color::srgb(1.0, 0.8, 0.2)), // Gold-ish
                StatsText,
            ));
        });

        // Bottom Bar (Controls)
        parent.spawn((
            Node {
                width: Val::Percent(100.0),
                height: Val::Px(30.0),
                align_items: AlignItems::Center,
                justify_content: JustifyContent::Center,
                ..default()
            },
            BackgroundColor(Color::srgb(0.0, 0.0, 0.0).with_alpha(0.6)),
        ))
        .with_children(|bottom_bar| {
             bottom_bar.spawn((
                Text::new("Controls: [Space] Spawn Item (Eve) | [T] Next Phase | [F5] Save | [F9] Load | [Drag] Move Items"),
                TextFont {
                    font_size: 14.0,
                    ..default()
                },
                TextColor(Color::srgb(0.8, 0.8, 0.8)),
            ));

             // Start Combat Button (Visible in Evening Only - Logic below needs to handle visibility, or we spawn it dynamically elsewhere.
             // For simplicity, let's spawn it here but toggle visibility in update_hud, or just add a button that is always there but only works in Evening?
             // Better: Add a distinct UI element for the button.)
             bottom_bar.spawn((
                 Button,
                 Node {
                     width: Val::Px(120.0),
                     height: Val::Px(24.0),
                     margin: UiRect::left(Val::Px(20.0)),
                     justify_content: JustifyContent::Center,
                     align_items: AlignItems::Center,
                     ..default()
                 },
                 BackgroundColor(Color::srgb(0.6, 0.1, 0.1)),
                 StartCombatButton,
             ))
             .with_children(|btn| {
                 btn.spawn((
                     Text::new("Start Combat"),
                     TextFont { font_size: 14.0, ..default() },
                     TextColor(Color::WHITE),
                 ));
             });
        });
    });
}

#[derive(Component)]
struct StartCombatButton;

fn update_hud(
    // Removed unused mut commands
    state: Res<State<GameState>>,
    player_stats: Res<PlayerStats>,
    time: Res<GlobalTime>,
    mut q_phase: Query<&mut Text, (With<PhaseText>, Without<StatsText>)>,
    mut q_stats: Query<&mut Text, (With<StatsText>, Without<PhaseText>)>,
    mut q_combat_btn: Query<&mut Visibility, With<StartCombatButton>>,
    q_interaction: Query<&Interaction, (Changed<Interaction>, With<StartCombatButton>)>,
    mut next_state: ResMut<NextState<GameState>>,
) {
    // Update Phase Text
    for mut text in q_phase.iter_mut() {
        let phase_name = match state.get() {
            GameState::AssetLoading => "Loading...",
            GameState::MainMenu => "Main Menu",
            GameState::DayPhase => "Day Phase (Metagame)",
            GameState::EveningPhase => "Evening Phase (Inventory)",
            GameState::NightPhase => "Night Phase (Combat)",
            GameState::EventResolution => "Event",
            GameState::GameOver => "Game Over",
        };
        let time_str = format!("Day {} {:02}:00", time.day, time.hour);
        **text = format!("{} - {}", phase_name, time_str);
    }

    // Update Stats Text
    for mut text in q_stats.iter_mut() {
        **text = format!(
            "Thalers: {} | Rep: {} | Inf: {}",
            player_stats.thalers, player_stats.reputation, player_stats.infection
        );
    }

    // Handle Combat Button Visibility & Click
    let show_button = *state.get() == GameState::EveningPhase;
    for mut vis in q_combat_btn.iter_mut() {
        *vis = if show_button { Visibility::Visible } else { Visibility::Hidden };
    }

    if show_button {
        for interaction in q_interaction.iter() {
            if *interaction == Interaction::Pressed {
                info!("Starting Combat!");
                next_state.set(GameState::NightPhase);
            }
        }
    }
}


==================================================
ФАЙЛ: src\plugins\visualization.rs
==================================================

use bevy::prelude::*;
use crate::plugins::inventory::{InventoryGridState, GridPosition, ItemRotation};
use crate::plugins::items::{ItemDatabase, ItemDefinition};
use crate::plugins::core::GameState;

pub struct VisualizationPlugin;

impl Plugin for VisualizationPlugin {
    fn build(&self, app: &mut App) {
        app.add_systems(Update, (draw_synergy_lines, draw_recipe_lines).run_if(in_state(GameState::EveningPhase)));
    }
}

// -------------------------------------------------------------------------------------------------
// Visualization Systems
// -------------------------------------------------------------------------------------------------

/// Draws lines between items that have active synergies.
/// Green lines for synergies.
fn draw_synergy_lines(
    mut gizmos: Gizmos,
    q_items: Query<(Entity, &GridPosition, &ItemRotation, &ItemDefinition)>,
    grid_state: Res<InventoryGridState>,
    q_tags: Query<&ItemDefinition>,
    q_transforms: Query<&GlobalTransform>,
) {
    // Iterate items to find active synergies
    for (entity, pos, rot, def) in q_items.iter() {
        if def.synergies.is_empty() { continue; }

        let start_node_transform = if let Ok(t) = q_transforms.get(entity) {
            t
        } else {
            continue;
        };

        let start_pos = start_node_transform.translation().truncate();

        for synergy in &def.synergies {
            // Calculate target grid position
            let rotated_offset_vec = InventoryGridState::get_rotated_shape(&vec![synergy.offset], rot.0);
            if rotated_offset_vec.is_empty() { continue; }
            let rotated_offset = rotated_offset_vec[0];
            let target_pos = IVec2::new(pos.0.x, pos.0.y) + rotated_offset;

            // Check if occupied
            if let Some(slot) = grid_state.slots.get(&target_pos) {
                if let Some(target_entity) = slot.occupier {
                    // Check tags
                    if let Ok(target_def) = q_tags.get(target_entity) {
                        if synergy.target_tags.iter().any(|req| target_def.tags.contains(req)) {
                             // Match found! Draw line.
                             if let Ok(target_transform) = q_transforms.get(target_entity) {
                                 let end_pos = target_transform.translation().truncate();

                                 // Draw Green Line for Synergy
                                 gizmos.line_2d(start_pos, end_pos, Color::srgb(0.0, 1.0, 0.0));
                             }
                        }
                    }
                }
            }
        }
    }
}

/// Draws lines for potential recipes.
/// Blue: Potential (neighboring ingredient).
/// Gold: Ready (all ingredients present).
fn draw_recipe_lines(
    mut gizmos: Gizmos,
    q_items: Query<(Entity, &GridPosition, &ItemDefinition, &ItemRotation)>,
    item_db: Res<ItemDatabase>,
    q_transforms: Query<&GlobalTransform>,
) {
    if item_db.recipes.is_empty() { return; }

    // Collect all items on grid
    let mut items_on_grid: Vec<(Entity, &ItemDefinition, &GridPosition, &ItemRotation)> = Vec::new();
    for (e, pos, def, rot) in q_items.iter() {
        items_on_grid.push((e, def, pos, rot));
    }

    // Naive O(R * N^2) check. R=recipes, N=items. N is small (~20).
    for recipe in &item_db.recipes {
        if recipe.ingredients.len() < 2 { continue; }

        for i in 0..recipe.ingredients.len() {
            for j in (i+1)..recipe.ingredients.len() {
                let id_a = &recipe.ingredients[i];
                let id_b = &recipe.ingredients[j];

                // Find items matching id_a
                let items_a: Vec<_> = items_on_grid.iter().filter(|(_, def, _, _)| def.id == *id_a).collect();
                // Find items matching id_b
                let items_b: Vec<_> = items_on_grid.iter().filter(|(_, def, _, _)| def.id == *id_b).collect();

                for (entity_a, def_a, pos_a, rot_a) in &items_a {
                    for (entity_b, def_b, pos_b, rot_b) in &items_b {
                        if entity_a == entity_b { continue; }

                        // Check adjacency
                        if are_adjacent(pos_a, rot_a, def_a, pos_b, rot_b, def_b) {
                             // Draw line
                             if let (Ok(t_a), Ok(t_b)) = (q_transforms.get(*entity_a), q_transforms.get(*entity_b)) {
                                 let p1 = t_a.translation().truncate();
                                 let p2 = t_b.translation().truncate();

                                 let color = Color::srgb(0.0, 0.0, 1.0); // Blue

                                 gizmos.line_2d(p1, p2, color);
                             }
                        }
                    }
                }
            }
        }
    }
}

fn are_adjacent(
    pos_a: &GridPosition, rot_a: &ItemRotation, def_a: &ItemDefinition,
    pos_b: &GridPosition, rot_b: &ItemRotation, def_b: &ItemDefinition
) -> bool {
    // Get all cells for A
    let shape_a = InventoryGridState::get_rotated_shape(&def_a.shape, rot_a.0);
    let cells_a: Vec<IVec2> = shape_a.iter().map(|offset| IVec2::new(pos_a.0.x, pos_a.0.y) + *offset).collect();

    // Get all cells for B
    let shape_b = InventoryGridState::get_rotated_shape(&def_b.shape, rot_b.0);
    let cells_b: Vec<IVec2> = shape_b.iter().map(|offset| IVec2::new(pos_b.0.x, pos_b.0.y) + *offset).collect();

    // Check if any cell in A is adjacent (dist 1) to any cell in B
    for ca in &cells_a {
        for cb in &cells_b {
            let dx = (ca.x - cb.x).abs();
            let dy = (ca.y - cb.y).abs();
            if dx + dy == 1 {
                return true;
            }
        }
    }
    false
}

